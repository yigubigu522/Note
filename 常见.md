# 自我介绍



面试官，您好，我叫李雨泽。来自哈尔滨理工大学计算机专业，目前正在大三阶段。我对计算机领域充满了热情，并且在校期间努力学习了各种相关课程，包括JavaEE、数据库和数据结构等。此外，我还积极参与了技术论坛的讨论，不断拓展自己的知识面。我具备一定的责任感和管理能力，曾参与过多项社会实践活动(731,核酸)，锻炼了自己的团队合作和沟通能力。在校期间，我利用课外时间深入学习了Java、数据库以及Spring框架等相关知识，并且完成了两个项目的开发。我对SSM、Spring Boot、Spring Cloud和数据库性能优化有一定的了解，同时也熟悉相关业务流程。然后我的求职意向是后端开发，能发挥自己的专业特长，因此决定面试咱们公司的这个岗位，希望有机会能够加入贵公司!谢谢！

我的第一个项目是一个个人博客，用于发布文章和自我学习，我主要实现了评论,浏览量，用户认证和鉴权，文件存储等功能。

我的第二个项目是一个电商平台，是一个spring cloud项目，基于多个微服务模块实现，使用Nacos做为微服务的注册与发现中心。引入gateway组件作为服务入口的统一管理。使用MinIO作为分布式文件存储，使用Open Feign作为服务间通信的组件。使用RabbitMQ提供分布式事务的服务。基于ES实现商品的检索等等。





面试官你好，我叫包明鉴，来自哈尔滨理工大学计算机科学与技术专业，是一名25届的学生，我在学校主修的课程有java、数据库系统、数据结构等计算机专业课。很感谢贵公司能给我这次面试的机会，我面试的岗位是Java后端实习生，从开始自学Java以来，我完成了两个开发项目，分别是一个博客项目和一个电商项目，在项目中也使用到了springcloud、springboot、mysql、redis、rabbitmq等技术，并且这些方面也比较了解，对相关业务的设计流程也比较熟悉。同时在校积极地参加各种集体活动，我未来的职业规划跟这个岗位也是息息相关，因此决定面试咱们公司的这个岗位，希望能获得此次机会，谢谢。

# linux

### 常见的linux命令

```
ls：列出当前目录下的文件和文件夹。
cd [directory]：切换当前工作目录。
pwd：显示当前工作目录的绝对路径。
mkdir [directory]：创建一个新的目录。
rm [file]：删除文件或目录。
cp [source] [destination]：复制文件或目录。
mv [source] [destination]：移动文件或目录。
cat [file]：显示文件内容。
less [file]：以交互式方式查看文件内容。
grep [pattern] [file]：在文件中查找匹配的文本。
find [directory] -name [pattern]：在指定目录中搜索文件。
chmod [permissions] [file]：修改文件权限。
chown [owner]:[group] [file]：修改文件所有者和所属组。
ps：显示当前运行的进程。
top：动态显示系统资源使用情况和进程信息。
kill [process_id]：终止指定进程。
shutdown：关闭或重启系统。
ifconfig：显示网络接口信息。
ping [host]：向指定主机发送 ICMP 请求。
scp [source] [destination]：在本地主机和远程主机之间安全地复制文件。
```

### 查看进程指令

**ps命令**：用于显示当前运行进程的快照。常用选项包括：

- `-e`：显示所有进程。
- `-f`：显示更详细的进程信息。
- `-u user`：显示特定用户的进程。

**top命令**：用于动态显示进程的运行情况。它会实时更新并显示当前系统的进程信息，包括CPU、内存、进程状态等。

### 创建一个文件用什么lInux命令

```
touch myfile.txt
```

### 查看磁盘大小的linux命令

```
df -h
du -sh /path/to/directory
```

### linux的一些定时调用

1.cron

2.at now + 1 hour 。。，。。命令在一小时后执行

# Docker常见操作

~~~ 
1. `docker pull <image>`：从 Docker Hub 或其他注册表中拉取镜像。
2. `docker run <image>`：运行一个容器。
3. `docker ps`：列出当前正在运行的容器。
4. `docker ps -a`：列出所有容器，包括已停止的。
5. `docker stop <container>`：停止一个正在运行的容器。
6. `docker start <container>`：启动一个已停止的容器。
7. `docker restart <container>`：重启一个容器。
8. `docker rm <container>`：删除一个容器。
9. `docker rmi <image>`：删除一个镜像。
10. `docker exec -it <container> <command>`：在运行的容器中执行命令。
11. `docker logs <container>`：查看容器的日志输出。
12. `docker build <path/to/Dockerfile>`：构建一个镜像。
13. `docker-compose up`：使用 Docker Compose 启动多个容器应用。
14. `docker-compose down`：停止并删除 Docker Compose 管理的容器。
15.创建docker docker create -p 3000:80 --name exampleApp3000 yoyomooc/exampleapp15
~~~

# Git常见操作

~~~ java
git clone ssh://xxx/xx.git                下载git库
git branch -a                                   查看所有分支
git checkout xxx                              切换到xxx分支
git branch                                        查看当前所属分支
git submodule init                         子模块初始化
git submodule update                  子模块更新
git status                                          查看本地代码状态
git pull --rebase                              从服务器拉取最新代码
git add xxx                                        将xxx文件加入待提交列表
git add .                                            将本地所有有修改文件加入待提交列表
git commit                                       提交代码到新任务
git commit --amend                              提交代码到已有任务
git push xxx                                     将本地修改push到git服务器
git reset HEAD^                             将本地状态恢复至代码未提交之前
~~~

冲突1：当你commit以后，在执行git pull --rebase的时候出现冲突，请按如下步骤解决：

1  找到冲突文件，解决冲突

2  执行git add xxx（xxx为冲突文件全路径）

3  执行git rebase --continue

4  执行git pull --rebase

5  执行git push

冲突2：当你本地有修改的时候，你执行了git stash，然后又从服务器上pull了最新代码（git pull --rebase），出现了冲突，请按如下方式解决：

1  找到冲突文件，解决冲突

2  执行git add xxx（xxx为冲突文件全路径）

3  git commit

4  git pull --rebase

5  git push

~~~ 
ls：列出目录内容。
cd：切换目录。
pwd：显示当前工作目录的路径。
mkdir：创建新目录。
rm：删除文件或目录。
cp：复制文件或目录。
mv：移动文件或目录，也可用于重命名文件。
cat：查看文件内容。
grep：在文件中搜索指定的模式。
chmod：修改文件权限。
chown：修改文件所有者。
sudo：以超级用户权限执行命令。
ps：显示当前运行的进程。
kill：终止进程。
top：显示系统中消耗资源最多的进程。
df：显示磁盘空间使用情况。
du：显示目录或文件的磁盘使用情况。
tar：打包和解压文件。
ssh：远程登录到其他计算机。
scp：在本地和远程系统之间安全地复制文件。
~~~





# Redis

### 缓存穿透、缓存击穿、缓存雪崩以及解决方案

**缓存穿透**：查询一个一定不存在的数据，从mysql查不到就不写入缓存，导致每次都要去mysql查，可能导致mysql挂掉

解决：①缓存null；②布隆过滤器

**缓存击穿**：查询某一个key时，这个key过期了，此时大量的请求进来压垮

解决：①不设计过期时间（逻辑过期，存一个时间字段），高可用②互斥锁，查询不到时加互斥锁如setnx，强一致，可能死锁

**缓存雪崩**：查询时大量的key过期或者redis垮掉，压垮数据库

解决：①随机的过期时间；②设置集群哨兵模式预防redis垮掉；③geteway限流

### 布隆过滤器

底层主要是先去初始化一个比较大数组，在一开始都是0，当一个key来了之后经过3次hash计算，找到数据的下标然后把数组中原来的0改为1，这样的话，三个数组的位置就能标明一个key的存在。查找的过程也是一样的。

缺点就是会误判，可能恰巧不存在的数据经过hash计算后对应到了三个1，但是误判率不会超过5%，误判率一定存在，要不就得增加数组长度，但是浪费内存，5%不至于在高并发条件下压垮数据库

### Redis和数据库双写一致

**保证强一致性时**：redission的读写锁，读时添加共享锁只能读，写时添加排他锁不能读不能写，保证其他线程读不到脏数据

**不保证强一致性时**：

①延时双删，先删redis，再更新mysql，最后过一段时间删除redis，时间控制不好可能有脏数据

②利用canal实时监控mysql，canal读取binlog日志从而更新缓存

③利用rabbitmq异步更新，数据更新时发送给mq，然后更新redis

### Redis的持久化方式

RDB：快照文件，把redis的数据写到硬盘上，从快照文件中恢复

AOF：追加文件，写操作存在aof文件中，恢复时重新执行一遍

rdb更快，但是容易出现数据丢失；aof慢但是风险小，设置刷盘策略每秒批量写入命令；二者结合使用

### AOF是默认打开的嘛

不是

### 为什么需要AOF和RDB结合使用

aof记录每次写操作，rdb每隔一定时间创建快照文件，结合可以快速恢复数据并降低恢复时间

### 过期删除策略

**惰性删除**：用的时候再看是否过期

**定期删除**：每隔一段时间全盘扫描一次

通常结合使用

### 淘汰数据的策略

8种，默认的内存满了就报错

LRU最近最少使用，LFU最少频率使用，项目中用allkeys-lru把常用数据留下

### 分布式锁

①setnx：redis是单线程的，只能由一个客户端对某个key设置值

②redission框架：setnx+lua（原子性）+看门狗

### setnx优点

由于redis的单线程的，用了命令之后，只能有一个客户端对某一个key设置值，在没有过期或删除key的时候是其他客户端是不能设置这个key的

### Redission分布式锁可重入吗

嗯，是可以重入的。这样做是为了避免死锁的产生。这个重入其实在内部就是判断是否是当前线程持有的锁，如果是当前线程持有的锁就会计数，如果释放锁就会在计算上减一。在存储数据的时候采用的hash结构，大key可以按照自己的业务进行定制，其中小key是当前线程的唯一标识，value是当前线程重入的次数

### Redission好处

- 可以控制锁的有效时长，看门狗机制，每隔一段时间就检查当前业务是否还持有锁，如果持有就增加加锁的持有时间，当业务执行完成之后需要使用释放锁就可以了
- 在高并发下，一个业务有可能会执行很快，先客户1持有锁的时候，客户2来了以后并不会马上拒绝，它会自旋不断尝试获取锁，如果客户1释放之后，客户2就可以马上持有锁，性能也得到了提升

### 主从一致问题

redission不能解决主从一致问题，如果线程1加锁成功master宕机，slave会变成新的master，此时线程2加锁会导致两个节点同时有一把琐

用redission的红锁，要在redis多个实例上创建锁，数量要过半。但是性能低

可以用zookeeper

### redis集群

**主从同步**：读写分离，一般主节点写，从节点读，主节点写入之后同步到从节点

**哨兵模式**：监控、自动恢复、通知，master故障，哨兵会选一个slave升成master

**分片集群**：分片集群主要解决的是，海量数据存储的问题，集群中有多个master，每个master保存不同数据，并且还可以给每个master设置多个slave节点，就可以继续增大集群的高并发能力。同时每个master之间通过ping监测彼此健康状态，就类似于哨兵模式了。当客户端请求可以访问集群任意节点，最终都会被转发到正确节点

### 主从同步流程

**全量复制**：从节点带着自己的repolid请求同步数据，主节点和从节点id如果不一致就会把自己的id和offset发送给从节点，同时主节点会bgsave，把生成的rdb文件发给从节点，如果这个时候主节点有变动，会记录日志到缓冲区，最后把日志发给从节点

**增量复制**：主节点获取从节点的offset值，然后把日志对应部分发给从节点

### 怎么保证高并发高可用

哨兵集群

### 集群脑裂怎么解决

master和slave和哨兵处于不同的网络分区，master网不好，会将一个slave升成master，但是还在给旧的master写数据，网恢复后会新的master数据丢失

可以设置至少要有一个slave才能同步数据；设置主从数据复制和同步的延迟时间，达不到要求就拒绝请求

### 分片集群怎么存储和读取

16384 个哈希槽，集群中每个主节点绑定了一定范围的哈希槽范围， key通过 决定放置哪个槽，通过槽找到对应的节点进行存储

### 为什么redis快

1、完全基于内存的，C语言编写

2、采用单线程，避免不必要的上下文切换可竞争条件

3、使用多路I/O复用模型，非阻塞IO

例如：bgsave 和 bgrewriteaof 都是在后台执行操作，不影响主线程的正常使用，不会产生阻塞

### I/O多路复用模型

I/O多路复用是指利用单个线程来同时监听多个Socket ，并在某个Socket可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源。目前的I/O多路复用都是采用的epoll模式实现，它会在通知用户进程Socket就绪的同时，把已就绪的Socket写入用户空间，不需要挨个遍历Socket来判断是否就绪，提升了性能。

其中Redis的网络模型就是使用I/O多路复用结合事件的处理器来应对多个Socket请求，比如，提供了连接应答处理器、命令回复处理器，命令请求处理器；

在Redis6.0之后，为了提升更好的性能，在命令回复处理器使用了多线程来处理回复事件，在命令请求处理器中，将命令的转换使用了多线程，增加命令转换速度，在命令执行的时候，依然是单线程

### 为什么用redis

- 缓存，可以加快访问速度，减轻数据库压力
- 分布式锁，确保在分布式环境下的数据一致性和并发控制
- 持久化机制

### Redis数据结构类型和使用场景

- str：存储单个值，例如用户会话数据、计数器等，缓存数据，简单的键值对；

- hash：适用于存储对象或实体的多个属性，比如存储用户信息、商品信息等；

- list：适用于实现队列、消息队列等场景；

- set：适用于存储唯一值，比如存储用户标签、点赞用户等；

- zset：适用于需要根据某个指标进行排序的场景，比如排行榜、带权重的队列等

### zset底层的数据结构

**跳跃表**：有序数据结构，类似于链表，但在链表的基础上增加了多级索引。这些索引使得跳跃表具有类似二分查找的效果，可以快速定位到目标节点；跳跃表按分数值排序元素，每个节点存储一个成员和对应的分数值

**哈希表**：存储元素和对应的分数值之间的映射关系。这样可以通过成员快速定位到对应的分数值，以及通过分数值快速查找到对应的成员

### 跳跃表（skipList）？

`SkipList`是在**有序链表**的基础上进行了扩展，解决了有序链表结构查找特定值困难的问题，查找特定值的时间复杂度为`O(logn)`，他是一种可以代替平衡树的数据结构。

它的效率和红黑树以及 AVL 树不相上下，但跳表的原理相当简单，只要你能熟练操作链表，就能轻松实现一个 `SkipList`。

### Redis使用场景

缓存、分布式锁、保存token、消息队列、延迟队列

### 用redis和mq实现一个延时队列（zset）

1. **使用 Redis 存储延时任务**：
   - 将待执行的任务存储在 Redis 中，并设置好执行时间。可以使用有序集合（Sorted Set）来存储任务，以任务的执行时间作为分数值，任务内容作为成员。
   - 当一个任务需要延时执行时，将其添加到有序集合中，并设置好执行时间。
2. **使用消息队列传递任务**：
   - 当任务的执行时间到达时，从有序集合中取出任务，并将任务内容发送到消息队列中。
   - 消息队列负责将任务分发给相应的消费者进行执行。
3. **消费者执行任务**：
   - 消费者监听消息队列中的任务，一旦有任务到达，则执行相应的操作。
   - 消费者执行任务后，可以根据需要更新任务状态或者从 Redis 中删除任务。

### Redis和MySQL区别

- redis存在内存里，mysql存在磁盘里
- redis多种数据类型，mysql是表结构
- redis用于缓存、分布式锁等，mysql存储数据
- redis要用持久化，mysql直接存磁盘

### redis与memcached的区别？

1. **支持存储的数据类型**：`redis`支持五种类型。`memcached`支持文本类型与二进制类型。
2. **网络IO模型**：`redis`是单线程的多路IO复用模型，`memcached`是多线程的非阻塞IO模式。
3. **`redis`支持数据持久化**，`memcached`不支持
4. 使用场景：`redis`适用于复杂的数据结构环境，有持久化需求。`memcached`适用于纯<k,v>且数据量矩大的环境下。

# MySQL

### 一条sql语句的底层的具体执行过程

- 连接器：建立连接，管理连接、校验用户身份；
- 查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；
- 解析 SQL，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；
- 执行 SQL：执行 SQL 共有三个阶段：
  - 预处理阶段：检查表或字段是否存在；将 `select *` 中的 `*` 符号扩展为表上的所有列。
  - 优化阶段：基于查询成本的考虑， 选择查询成本最小的执行计划；
  - 执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；

### 如何定位慢查询

mysql自带慢日志查询功能，可以设置超过2s的就会记录到日志中，就可以在日志文件中找到比较慢的sql

### 如何分析慢sql

mysql自动的执行计划explain查看这条sql的执行情况

key或key_len可以看是否命中索引，如果本身添加索引可以判断索引是否失效

type字段可以查看是否存在全盘扫描或全索引

extra字段可以看出是否存在回表，如果出现可以尝试添加索引或者修改返回字段

### sql较慢怎么优化

定位慢查询+分析慢sql

### 什么是索引

索引是帮助mysql高效获取数据的数据结构，主要用来提高数据的检索效率，降低IO成本，降低CPU的消耗

### 索引有哪些

B+树索引，哈希索引

聚簇索引，非聚簇索引

主键索引，唯一索引，复合索引，外键索引，普通索引

### 索引的数据结构

B+树，第一阶数更多路径更短，第二非叶子节点存指针叶子节点存数据，磁盘读写代价更低，第三底层是双向链表便于查询

### B+树是怎么实现索引

MyISAM：采用的非聚簇索引，B+树的非叶子节点存储索引值和指向子节点的指针，叶子节点上存放的是索引值和数据在磁盘上的物理地址，所以通过索引定位到数据地址后，需要到磁盘上回表获取数据

Innodb采用的聚簇索引(主键索引)，B+树的非叶子节点(内部节点)存放的是索引值和指向子节点的指针，叶子节点上存放的是索引值和数据。

非聚簇索引，B+树的非叶子节点存储索引值和指向子节点的指针，叶子节点存放的是索引值和聚簇索引值。因此非聚簇索引需要先遍历非聚簇索引B+树定位到聚簇索引的值，再到聚簇索引上回表获取数据。

聚簇索引的优点：可以避免每棵索引树上都存放数据，使得在相同的内存空间下存放的更多的索引节点，减少磁盘IO。

### 为什么不用红黑树做索引

MySQL的数据都是存放在磁盘，因此磁盘IO是MySQL的性能瓶颈，而二叉树，二叉搜索树，二叉平衡树，红黑树 都属于二叉树，当MySQL表中的数据量比较大时，索引的体积也会很大，树高就会很大，内存放不下的需要从磁盘读取，树的层次太高的话，读取磁盘的次数就多了，影响MySQL的使用性能。

### B树和B+树的区别

- B树的非叶子节点和叶子节点都存数据，B+树的所有数据都在叶子节点，查询的时候B+树查找效率更稳定
- B+树叶子节点存数据是双向链表，范围查询效率更高

### 聚集索引和非聚集索引

聚簇索引：数据和索引放在一起，B+树的叶子节点保存了整行数据，有且只有一个

非聚簇索引：数据和索引分开放，B+树的叶子节点存对应的主键，可以有多个

### 回表？怎么避免回表

通过二级索引找到对应的主键值，再用聚簇索引对应的整行数据

使用覆盖索引；避免使用select*；使用联合索引

### 覆盖索引

select查询使用了索引，在返回的列，必须在索引中全部能找到。如果用id查询，直接走聚簇索引一次扫描性能高；如果用二级索引查询，返回的列中没有创建索引，可能会触发回表，尽量避免用select*，尽量在返回的列中都包含添加索引的字段

### 超大分页怎么解决

超大分页一般都是在数据量比较大时，我们使用了limit分页查询，并且需要对数据进行排序，这个时候效率就很低，我们可以采用覆盖索引和子查询来解决

先分页查询数据的id字段，确定了id之后，再用子查询来过滤，只查询这个id列表中的数据就可以了

因为查询id的时候，走的覆盖索引，所以效率可以提升很多

### 建索引注意事项

大前提就是表中数据超过10w条以上才会创建索引，并且添加索引的字段都是查询比较频繁的字段，一般像作为查询条件，排序字段或分组的字段等

通常创建索引时都是用复合索引创建，一条sql返回的值尽量用覆盖索引

如果某一个字段的内容较长，我们会考虑使用前缀索引来使用，当然并不是所有的字段都要添加索引，这个索引的数量也要控制，因为添加索引也会导致新增改的速度变慢

### 索引失效的场景

比如，索引在使用的时候没有遵循最左匹配法则，第二个是，模糊查询，如果%号在前面也会导致索引失效。如果在添加索引的字段上进行了运算操作或者类型转换也都会导致索引失效。

我们之前还遇到过一个就是，如果使用了复合索引，中间使用了范围查询，右边的条件索引也会失效

所以，通常情况下，想要判断出这条sql是否有索引失效的情况，可以使用explain执行计划来分析

### 使用了范围查找还能用到索引吗

不能，MySQL 使用 B+ 树索引来加速数据查询，对于等值查询来说，B+ 树索引能够快速定位到对应的叶子节点。然而，对于范围查询来说，B+ 树索引的叶子节点并不是连续存储的，而是通过链表进行连接。这就导致在执行范围查询时，需要遍历链表中的每个节点，而不是像等值查询那样可以直接定位到节点。

### sql优化

建表的时候、使用索引、sql语句的编写、主从复制，读写分离，还有一个是如果量比较大的话，可以考虑分库分表

### 建表注意事项

在定义字段的时候需要结合字段的内容来选择合适的类型，如果是数值的话，像tinyint、int 、bigint这些类型，要根据实际情况选择。如果是字符串类型，也是结合存储的内容来选择char和varchar或者text类型

### sql语句注意事项

- SELECT语句务必指明字段名称，不要直接使用select * 
- 注意SQL语句避免造成索引失效的写法
- 如果是聚合查询，尽量用union all代替union ，union会多一次过滤，效率比较低
- 如果是表关联的话，尽量使用innerjoin ，不要使用用left join、right join，如必须使用 一定要以小表为驱动

### 事务是什么

一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位

### 事务的特性

原子性A：要么都成功要么都失败 --undolog回滚日志

一致性C：操作前后数据一致 --AID，undolog，隔离级别

隔离性I：每个事务不会互相干扰  --MVCC / 锁

持久性D：结束后对数据的修改是永久的 --redolog重做日志

### 事务带来的问题

第一是脏读， T1修改某条数据但是没提交，T2读这个没提交的数据，那么T2读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。

第二是不可重复读：比如在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。

第三是幻读（Phantom read）：幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。

### 事务的隔离级别

读未提交；读已提交（解决脏读）；可重复读（解决脏读和不可重复读）（默认）；串行化（全都解决）

### 项目中用到事务了吗

订单

### undolog和redolog

其中redo log日志记录的是数据页的物理变化，服务宕机可用来同步数据

而undo log 不同，它主要记录的是逻辑日志，当事务回滚时，通过逆操作恢复原来的数据，比如我们删除一条数据的时候，就会在undo log日志文件中新增一条delete语句，如果发生回滚就执行逆操作；

redo log保证了事务的持久性，undo log保证了事务的原子性和一致性

### MVCC

mvcc的意思是多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，它的底层实现主要是分为了三个部分，第一个是隐藏字段，第二个是undo log日志，第三个是readView读视图

隐藏字段是指：在mysql中给每个表都设置了隐藏字段，有一个是trx_id(事务id)，记录每一次操作的事务id，是自增的；另一个字段是roll_pointer(回滚指针)，指向上一个版本的事务版本记录地址

undo log主要的作用是记录回滚日志，存储老版本数据，在内部会形成一个版本链，在多个事务并行操作某一行记录，记录不同事务修改数据的版本，通过roll_pointer指针形成一个链表

readView解决的是一个事务查询选择版本的问题，在内部定义了一些匹配规则和当前的一些事务id判断该访问那个版本的数据，不同的隔离级别快照读是不一样的，最终的访问的结果不一样。如果是rc隔离级别，每一次执行快照读时生成ReadView，如果是rr隔离级别仅在事务中第一次执行快照读时生成ReadView，后续复用

### mysql主从同步

MySQL主从复制的核心就是二进制日志(DDL（数据定义语言）语句和 DML（数据操纵语言）语句)，它的步骤是这样的：

第一：主库在事务提交时，会把数据变更记录在二进制日志文件 Binlog 中。

第二：从库读取主库的二进制日志文件 Binlog ，写入到从库的中继日志Relay Log 。

第三：从库重做中继日志中的事件，将改变反映它自己的数据

### mysql存储引擎

InnoDB，MyIsam，Memory，CSV。。。

### InnoDB和MyIsam区别

1. 事务支持：InnoDB 支持事务，而 MyISAM 不支持。
2. 表锁和行锁：InnoDB 支持行级锁，MyISAM 支持表级锁。
3. 外键支持：InnoDB 支持外键，MyISAM 不支持。
4. 处理速度：MyISAM 的读性能优于 InnoDB，而 InnoDB 的写性能优于 MyISAM。
5. myisam都是非聚簇索引
6. innodb非聚簇索引data域存主键值，myisam存地址

### MySQL如何处理高并发问题

主从复制

读写分离：让主数据库处理事务性增、改、删操作，而从数据库处理SELECT查询操作

基于程序代码内部实现

```sql
在代码中根据select 、insert进行路由分类，这类方法也是目前生产环境下应用最广泛的。
优点是性能较好，因为程序在代码中实现，不需要增加额外的硬件开支，缺点是需要开发人员来实现，运维人员无从下手。
```

 实现 ：Spring提供的路由数据源 +AOP

基于中间代理层实现

```undefined
代理一般介于应用服务器和数据库服务器之间，代理数据库服务器接收到应用服务器的请求后根据判断后转发到，
后端数据库，有以下代表性的程序。
```

### 数据库有哪几范式

第一范式（1NF）：要求数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值

第二范式（2NF）：要求实体中每一行的所有非主属性都必须完全依赖于主键

第三范式（2NF）：实体中的属性不能是其他实体中的非主属性。因为这样会出现冗余。即：属性不依赖于其他非主属性。

### mysql有几种日志

- undo log（回滚日志）：是 Innodb 存储引擎层生成的日志，实现了事务中的原子性，主要用于事务回滚和MVCC。
- redo log（重做日志）：是 Innodb 存储引擎层生成的日志，实现了事务中的持久性，主要用于掉电等故障恢复；
- binlog （归档日志）：是 Server 层生成的日志，主要用于数据备份和主从复制；

### 可重复读怎么实现的

可重复读隔离级是由MVCC实现的，实现的方式是开始事务后（执行begin 语句后），在执行第一个查询语句后，会创建一个Read View，后续的查询语句利用这个Read View，通过这个Read View 就可以在undo log 版本链找到事务开始时的数据，所以事务过程中每次查询的数据都是一样的

### 联合索引 (a, b, c)，where a = 1, c = 1, b = 1，能用到联合索引吗

不能

### MySQL中有哪些锁？

在Mysql里，根据加锁的范围，可以分为**全局锁**、**表级锁**和**行锁**三类。

- **全局锁：**

**全局锁的使用**:中心后，整个数据库就处于只读状态了，这时其他线程执行以下操作，都会被阻塞。

```sql
flush tables with read lock //加锁
unlock tables //释放锁
```

**全局锁的应用场景**：全库逻辑备份。在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。

**加全局锁的缺点**：意味着整个数据库都是只读状态。那么如果数据库里有很多数据，备份就会花费很多时间，关键是是备份期间，业务只能读数据，而不能更新数据，这样会造成业务停滞。

- **表级锁**：

  - 表锁：不过尽量避免在使用 InnoDB 引擎的表使用表锁，因为表锁的颗粒度太大，会影响并发性能，**InnoDB 牛逼的地方在于实现了颗粒度更细的行级锁**。

    ```sql
    //表级别的共享锁，也就是读锁
    lock tables t_students read;
    
    //表级别的独占锁，也就是写锁
    lock tables t_student write;
    
    //释放表锁
    unlock tables
    ```

  - 元数据锁（MDL）：我们不需要显示的使用MDL，因为我们对数据库进行操作时，会自动给这个表加上MDL。在事务提交后释放

    - 对一张表进行CRUD操作时，加的是MDL读锁
    - 对一张表做结构变更操作的时候，加的是MDL写锁

  - 意向锁：**意向锁的目的是为了快速判断表里是否有记录被加锁**。

    - 在使用 InnoDB 引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」；
    - 在使用 InnoDB 引擎的表里对某些纪录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」；

  - Auto-INC锁：表里的主键通常都会设置成自增的，这是通过对主键字段声明 `AUTO_INCREMENT` 属性实现的。之后可以在插入数据时，可以不指定主键的值，数据库会自动给主键赋值递增的值，这主要是通过 **AUTO-INC 锁**实现的。UTO-INC 锁是特殊的表锁机制，锁**不是再一个事务提交后才释放，而是再执行完插入语句后就会立即释放**。在插入数据时，会加一个表级别的 AUTO-INC 锁，然后为被 `AUTO_INCREMENT` 修饰的字段赋值递增的值，等插入语句执行完成后，才会把 AUTO-INC 锁释放掉。那么，一个事务在持有 AUTO-INC 锁的过程中，其他事务的如果要向该表插入语句都会被阻塞，从而保证插入数据时，被 `AUTO_INCREMENT` 修饰的字段的值是连续递增的。InnoDB 存储引擎提供了一种**轻量级的锁**来实现自增。一样也是在插入数据的时候，会为被 `AUTO_INCREMENT` 修饰的字段加上轻量级锁，**然后给该字段赋值一个自增的值，就把这个轻量级锁释放了，而不需要等待整个插入语句执行完后才释放锁**。

- **行锁：**

  - **Record Lock记录锁，**也就是仅仅将一条记录锁上。记录锁是有 S 锁和 X 锁之分的：
    - 当一个事务对一条记录加了 S 型记录锁后，其他事务也可以继续对该记录加 S 型记录锁**（S 型与 S 锁兼容）**，但是不可以对该记录加 X 型记录锁**（S 型与 X 锁不兼容）**;
    - 当一个事务对一条记录加了 X 型记录锁后，其他事务既不可以对该记录加 S 型记录锁**（S 型与 X 锁不兼容）**，也不可以对该记录加 X 型记录锁**（X 型与 X 锁不兼容）**。
  - **Gap Lock间隙锁**，锁定一个范围，但是不包含记录本身。只存在于可重复读隔离级别，目的是**为了解决可重复读隔离级别下幻读的现象。**假设，表中有一个范围 id 为（3，5）间隙锁，那么其他事务就无法插入 id = 4 这条记录了，这样就有效的防止幻读现象的发生。**间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的**。
  - **Next-Key Lock**： Record Lock +Gap Lock的组合，锁定一个范围，并且锁定记录本身。假设，表中有一个范围 id 为（3，5] 的 next-key lock，那么其他事务即不能插入 id = 4 记录，也不能修改 id = 5 这条记录。
  - **插入意向锁：**一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁

### 数据库建表注意点(技巧)

名字，字段类型，字段长度，字段个数，主键，存储引擎，NOT NULL，外键，索引，时间字段，金额字段，唯一索引，字符集，排序规则，大字段

# Spring

### 单例bean安全吗

不是，多个用户访问的时候会给每个请求分配一个线程，当他们中间有对单例bean的成员属性的修改，就要考虑线程安全问题

我们通常用的bean都是不可变的，比如service和dao，所以某种程度上来说是安全的

如果bean有多种状态，就要将多态bean改为多例

### IOC

依赖注入/控制反转，意思就是被调用者不再由调用者调用，创建被调用者的容器由spring来完成，然后注入给调用者；A调用B，A不需要主动获取B，而是由其他人自动将B送上门来

### IOC容器的初始化流程

通过解析和加载后生成BeanDefinition，然后把BeanDefinition注册到IOC容器。

通过注解或者xml声明的bean都会解析得到一个BeanDefinition实体，实体中包含这个bean中定义的基本属性。

最后把这个BeanDefinition保存到一个Map集合里面，从而完成了IOC的初始化

### IOC的工作流程

①第一个阶段，IOC容器的初始化

根据程序中Bean的声明方式通过解析和加载后生成BeanDefinition实体，实体中包含bean中定义的基本属性，然后把他注入到IOC容器

②第二个阶段，完成Bean的初始化及依赖注入

两个事情，通过反射针对没有设置lazy-init属性的单例bean进行初始化；完成bean的依赖注入

③第三个阶段，bean的使用

通常会通过@Autowired或者BeanFactory.getBean()从IOC容器中获取指定的bean

### 依赖注入的实现方式

**构造方法注入**：检查被注入对象的构造方法，取得他所需要的依赖对象列表，然后为其注入相应的对象

**setter方法注入**：只需要给依赖对象对应的属性添加setter方法，就可以通过setter方法将依赖对象注入到被依赖对象中

### AOP

面向切面编程，在spring中通常将那些与业务无关但是对多个对象产生影响的公共行为和逻辑抽取公共模块复用，降低耦合

### AOP的底层原理

动态代理，在运行时动态生成代理对象，通过代理链实现对目标对象的方法拦截。

初始化时会看目标类有没有实现InvocationHandler接口或者是Proxy类，如果实现了接口，就使用JDK动态代理，通过反射来接收被代理的类。如果没实现就利用cglib进行AOP动态代理

### AOP的应用

日志，利用环绕通知+切点表达式。这个表达式就是要找到要记录日志的方法，然后通过环绕通知的参数获取请求方法的参数，比

如类信息、方法信息、注解、请求方式等，获取到这些参数以后，保存到数据库

### 反射，反射创建对象的方式

反射允许对成员变量、成员方法、构造方法的信息进行编程访问

首先获取class对象，有三种，.getclass()、.class()、Class.forName()

创建对象：class类的newInstance；先获取构造对象getConstructor，再constructor.newInstace()

### 动态代理的实现

动态代理实现方法的增强，可以在不修改源代码的情况下增强一些方法

**JDK动态代理**：反射实现，拿到代理对象的方法等。通过Proxy类的newProxyInstance方法来生成代理对象，代理类继承了Proxy类并且实现了要代理的接口，由于java不支持多继承，所以JDK动态代理不能代理类

**cglib动态代理**：字节码技术，通过目标类的字节码为一个类创建子类，在子类中采用方法拦截拦截所有父类方法的调用，顺势织入

### JDK动态代理和CGLib动态代理的区别

jdk只能代理接口，cglib都能；

实现原理不同

### Spring事务如何实现

spring实现的事务本质就是aop完成，对方法前后进行拦截，在执行方法之前开启事务，在执行完目标方法之后根据执行情况提交或者回滚事务

### Spring事务传播机制

7种，多个事务的方法在相互调用时，事务是如何在这些方法间传播的

- 默认：如果当前存在事务，就加入该事务，如果不存在就新建一个事务
- 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行
- 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常

### Spring事务失效场景

如果方法上异常捕获处理，自己处理了异常，没有抛出，就会导致事务失效，所以一般处理了异常以后，别忘了抛出去就行了

如果方法抛出检查异常，如果报错也会导致事务失效，最后在spring事务的注解上，就是@Transactional上配置rollbackFor属性为Exception，这样别管是什么异常，都会回滚事务

如果方法上不是public修饰的，也会导致事务失效

### bean生命周期

```
首先会通过一个非常重要的类，叫做BeanDefinition获取bean的定义信息，这里面就封装了bean的所有信息，比如，类的全路径，是否是延迟加载，是否是单例等等这些信息

在创建bean的时候，第一步是调用构造函数实例化bean
第二步是bean的依赖注入，比如一些set方法注入，像平时开发用的@Autowire都是这一步完成
第三步是处理Aware接口，如果某一个bean实现了Aware接口就会重写方法执行
第四步是bean的后置处理器BeanPostProcessor，这个是前置处理器
第五步是初始化方法，比如实现了接口InitializingBean或者自定义了方法init-method标签或@PostContruct
第六步是执行了bean的后置处理器BeanPostProcessor，主要是对bean进行增强，有可能在这里产生代理对象
最后一步是销毁bean
```

### bean的注入方式

- 使用xml的方式来声明Bean的定义，Spring容器在启动的时候会加载并解析这个xml，把bean装载到IOC容器中
- @Import注解，导入配置类或者普通的Bean
- 使用@Configuration注解声明配置类，并使用@Bean注解实现Bean的定义

### bean的作用域

singleton : IoC 容器中只有唯一的 bean 实例。Spring 中的 bean 默认都是单例的，是对单例设计模式的应用。
prototype : 每次获取都会创建一个新的 bean 实例。也就是说，连续 getBean() 两次，得到的是不同的 Bean 实例。
request: 每一次 HTTP 请求都会产生一个新的 bean（请求 bean），该 bean 仅在当前 HTTP request 内有效。
session: 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean（会话 bean），该 bean 仅在当前 HTTP session 内有效。
application：每个 Web 应用在启动时创建一个 Bean（应用 Bean），该 bean 仅在当前应用启动时间内有效。
websocket：每一次 WebSocket 会话产生一个新的 bean。


### spring循环依赖如何解决

两个或两个以上的bean互相持有对方,最终形成闭环。比如A依赖于B,B依赖于A

三级缓存

①一级缓存：单例池，缓存已经经历了完整的生命周期，已经初始化完成的bean对象

②二级缓存：缓存早期的bean对象（生命周期还没走完）

③三级缓存：缓存的是ObjectFactory，表示对象工厂，用来创建某个对象的

```
第一，先实例A对象，同时会创建工厂对象存入三级缓存
第二，A在初始化的时候需要B对象，这个走B的创建的逻辑
第三，B实例化完成，也会创建工厂对象存入三级缓存 
第四，B需要注入A，通过三级缓存中获取A的工厂对象来生成一个A的对象同时存入二级缓存，这个是有两种情况，一个是可能是A的普通对象，另外一个是A的代理对象，都可以让ObjectFactory来生产对应的对象，这也是三级缓存的关键
第五，B通过从通过二级缓存获得到A的对象后可以正常注入，B创建成功，存入一级缓存
第六，回到A对象初始化，因为B对象已经创建完成，则可以直接注入B，A创建成功存入一次缓存
第七，二级缓存中的临时对象A清除
```

### 构造方法循环依赖

bean生命周期中构造方法第一个执行，spring解决不了，可以用@Lazy懒加载，什么时候需要对象再进行bean对象的创建

### spring常见注解

第一类是：声明bean，有@Component、@Service、@Repository、@Controller

第二类是：依赖注入相关的，有@Autowired、@Qualifier、@Resourse

第三类是：设置作用域 @Scope

第四类是：spring配置相关的，比如@Configuration，@ComponentScan 和@Bean

第五类是：跟aop相关做增强的注解 @Aspect，@Before，@After，@Around

### @Autowired、@Resource区别

都是用来依赖注入的注解

- a是spring定义的注解，r是java定义的注解
- @Autowired 先根据类型再根据名称查询，而 @Resource 先根据名称再根据类型查询
- @Autowired 既支持构造方法注入，又支持属性注入和 Setter 注入，而 @Resource 只支持属性注入和 Setter 注入

# SpringMVC

### springmvc执行流程

前端控制器（调度中心）；处理器映射器；处理器适配器（处理参数和返回值）；视图解析器

```
1、用户发送出请求到前端控制器，这是一个调度中心
2、前端控制器收到请求调用处理器映射器。
3、处理器映射器找到具体的处理器，生成处理器对象及处理器拦截器(如果有)，再一起返回给前端控制器。
4、前端控制器调用处理器适配器。
5、处理器适配器经过适配调用具体的处理器（Handler/Controller）。
6、Controller执行完成返回ModelAndView对象。
7、处理器适配器将Controller执行结果ModelAndView返回给前端控制器。
8、前端控制器将ModelAndView传给视图解析器。
9、视图解析器解析后返回具体View（视图）。
10、前端控制器根据View进行渲染视图（即将模型数据填充至视图中）。
11、前端控制器响应用户。
当然现在的开发，基本都是前后端分离的开发的，并没有视图这些，一般都是handler中使用Response直接结果返回
```

### springmvc常见注解

@RequestMapping：用于映射请求路径；

@RequestBody：注解实现接收http请求的json数据，将json转换为java对象；

@RequestParam：指定请求参数的名称；

@PathViriable：从请求路径下中获取请求参数(/user/{id})，传递给方法的形式参数；

@ResponseBody：注解实现将controller方法返回对象转化为json对象响应给客户端。

@RequestHeader：获取指定的请求头数据，还有像@PostMapping、@GetMapping这些。



# MyBatis

### mybatis执行流程

```
1.读取MyBatis配置文件：mybatis-config.xml加载运行环境和映射文件
2.构造会话工厂SqlSessionFactory，一个项目只需要一个，单例的，一般由spring进行管理
3.会话工厂创建SqlSession对象，这里面就含了执行SQL语句的所有方法
4.操作数据库的接口，Executor执行器，同时负责查询缓存的维护
5.Executor接口的执行方法中有一个MappedStatement类型的参数，封装了映射信息
6.输入参数映射
7.输出结果映射
```

### mybatis延迟加载

就是在需要用到数据时才进行加载，不需要用到数据时就不加载数据。

Mybatis支持一对一关联对象和一对多关联集合对象的延迟加载。在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false，默认是关闭的

```
延迟加载在底层主要使用的CGLIB动态代理完成的
第一是，使用CGLIB创建目标对象的代理对象，这里的目标对象就是开启了延迟加载的mapper
第二个是当调用目标方法时，进入拦截器invoke方法，发现目标方法是null值，再执行sql查询
第三个是获取数据以后，调用set方法设置属性值，再继续查询目标方法，就有值了
```

### mybatis缓存

一级缓存：默认开启，当在同一个sqlsesstion中执行相同的sql语句时，会将查询到的数据存在一级缓存中，以便下一次查询时直接从缓存中获取数据，提高查询效率，生命周期和本地sqlsesstion一样。

二级缓存：多个sqlsesstion共享，可以避免多个sqlsesstion查询同一条数据，提高性能

### MyBatis中#{}和${}的区别

- $符是直接拼成sql的 ，#符则会以字符串的形式 与sql进行拼接。


- #会自动给传进来的值加上单引号，$不会。#会进行预编译，而且会进行类型匹配，参数是在编译之后填充进去的，所以不需要加上单引号

- #能够有效防止sql注入，$不能

- 当使用group by的时候，只能用$

### MyBatis中的动态标签

if，where，trim(拼接，去除sql前缀后缀)，set，foreach(用于动态生成 SQL 中的 IN 子句)

### JDBC流程

①加载数据库驱动

②建立数据库连接

③创建Statement对象，用来执行sql语句

④执行sql语句

⑤处理结果集

⑥释放资源

### JDBC有哪些不足之处，mybatis是如何解决的？

1、数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题。 

解决：在 SqlMapConfig.xml 中配置数据链接池，使用连接池管理数据库链接。 

2、Sql 语句写在代码中造成代码不易维护，实际应用 sql 变化的可能较大，sql 变动需要改变 java 代码。 

解决：将 Sql 语句配置在 XXXXmapper.xml 文件中与 java 代码分离。 

3、向 sql 语句传参数麻烦，因为 sql 语句的 where 条件不一定，可能多也可能少，占位符需要和参数一一对应。 

解决： Mybatis 自动将 java 对象映射至 sql 语句。 

4、对结果集解析麻烦，sql 变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成 pojo 对象解析比较方便。

# SpringBoot

### 简单介绍springboot

springboot是spring家族中的一个全新框架，用来简化spring程序的创建和开发过程。在以往我们通过SpringMVC+Spring+Mybatis框架进行开发的时候，我们需要配置web.xml，spring配置，mybatis配置，然后整合在一起，而springboot抛弃了繁琐的xml配置过程，采用大量默认的配置来简化我们的spring开发过程。

SpringBoot化繁为简，使开发变得更加的简单迅速。

### Springboot核心注解

启动类上面的注解是@SpringBootApplication，它也是 Spring Boot 的核心注解，主要组合包含
了以下 3 个注解：

* @SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。
* @EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项， 例
  如： java 如关闭数据源自动配置功能： @SpringBootApplication(exclude = { DataSourceAutoConfiguration.class })。
* @ComponentScan：Spring组件扫描。

### springboot启动流程

1、首先从main找到run()方法，在执行run()方法之前new一个SpringApplication对象
2、进入run()方法，创建应用监听器SpringApplicationRunListeners开始监听
3、然后加载SpringBoot配置环境(ConfigurableEnvironment)，然后把配置环境(Environment)加入监听对象中
4、然后加载应用上下文(ConfigurableApplicationContext)，当做run方法的返回对象
5、最后创建Spring容器，refreshContext(context)，实现starter自动化配置和bean的实例化等工作。

### springboot自动装配原理

springboot在启动时会调用run()方法，run方法会刷新容器，刷新容器的时候会扫描classpath下面的包中的META-INF/spring.factories文件，在这个文件中记录了好多的自动配置类，在刷新容器的时候会将这些自动配置类加载到容器中，然后根据这些配置类中的条件注解来判断是否将这些配置类在容器中进行实例化，这些条件主要是判断项目是否有相关的jar包或者是否引入了相关的bean，这样springboot就完成了自动装配。

# SpringCloud

### 微服务项目和传统开发项目开发有什么不同

采用分布式架构模块化开发，每个服务都是独立的，降低耦合度，实现快速开发部署

不会出现一个服务挂了导致整个系统崩溃；可以根据访问量动态调整服务数量；高扩展性

### SpringCloud组件

- 注册中心：Eureka，Nacos
- 负载均衡：Ribbon
- 远程调用：Feign
- 服务熔断：Hystrix，sentinel
- 网关：gateway

### 服务注册和发现

**服务注册**：服务提供者需要把自己的信息注册到eureka，由eureka来保存这些信息，比如服务名称、ip、端口等等

**服务发现**：消费者向eureka拉取服务列表信息，如果服务提供者有集群，则消费者会利用负载均衡算法，选择一个发起调用

**服务监控**：服务提供者会每隔30秒向eureka发送心跳，报告健康状态，如果eureka服务90秒没接收到心跳，从eureka中剔除

### 介绍一下nacos

提供服务注册、发现和监控，服务提供者把自己的信息注册到nacos，由nacos来保存这些信息，然后nacos可以监测提供者的状态，并进行及时的消息推送

### 使用nacos做注册中心有什么好处

### 如果要你实现一个nacos怎么实现

### nacos注册中心每个服务的监听

### NACOS的底层实现原理

1. **服务注册原理：**在`nacos`的服务端，有一个用来**管理微服务实例的容器**，注册中心将微服务的实例交由`ServiceHolder`处理，`ServiceHolder`为微服务提供空间并将它的所有实例挂在该空间下。服务注册完成后提供者将于注册中心维护心跳机制，心跳机制可以保证注册中心可以及时的剔除失效的实例。

2. **服务发现原理：**服务完成注册之后，消费者可以向注册中心订阅某个服务，并提交一个监视器，当注册中心的服务发生变更时监听器会收到通知，然后消费者可以更新本地的服务实例列表，以保证所有的服务均可用。

3. **nacos的负载均衡：**`Nacos` 的客户端在获取到服务的完整实例列表后，会在客户端进行负载均衡算法来获取一个可用的实例，模式使用的是随机获取的方式。

### nacos和eureka区别

**共同点**：

- 都支持服务注册和拉取
- 都支持心跳方式监测

**不同点**：

- nacos的服务端可以主动检测提供者的状态，临时实例用心跳，非临时实例主动检测
- nacos支持服务列表更新消息推送，更及时
- nacos集群默认用AP方式，集群中存在非临时实例时用CP模式；eureka用AP
- nacos还支持配置中心，eureka只有注册中心

### 负载均衡

ribbon，当发起远程调用时，ribbon先从注册中心拉取服务地址列表，然后按照一定的路由策略选择一个发起远程调用，一般的调用策略是轮询

### 负载均衡策略

①简单轮询

②按权重，响应时间越大，权重越小

③随机

④先按区域，再轮询（默认）

### 服务雪崩

服务雪崩是指一个服务失败，导致整条链路的服务都失败的情形，一般我们在项目解决的话就是两种方案，第一个是服务降级，第二个是服务熔断，如果流量太大的话，可以考虑限流

**服务降级**：服务自我保护的一种方式，或者保护下游服务的一种方式，用于确保服务不会受请求突增影响变得不可用，确保服务不会崩溃，一般在实际开发中与feign接口整合，编写降级逻辑

**服务熔断**：默认关闭，需要手动打开，如果检测到 10 秒内请求的失败率超过 50%，就触发熔断机制。之后每隔 5 秒重新尝试请求微服务，如果微服务不能响应，继续走熔断机制。如果微服务可达，则关闭熔断机制，恢复正常请求

### 常见限流算法

漏桶：是把请求存入到桶中，以固定速率从桶中流出，可以让我们的服务做到绝对的平均，起到很好的限流效果

令牌桶：在桶中存储的是令牌，按照一定的速率生成令牌，每个请求都要先申请令牌，申请到令牌以后才能正常请求，也可以起到很好的限流作用

区别：漏桶和令牌桶都可以处理突发流量，其中漏桶可以做到绝对的平滑，令牌桶有可能会产生突发大量请求的情况，一般nginx限流采用的漏桶，spring cloud gateway中可以支持令牌桶算法

### CAP理论

C：一致性	A：可用性	P：分区容错性
不能同时保证CAP

P指的是两个分区之间可能无法通信，所以一定要保证P
C指的是假设写操作之后的读操作必须返回值。假如a给g1写操作10改成20，同时读g2，那么最后结果不一样
A指的是操作后立刻返回值。

那么如果想保证C，在操作g1时就要锁住g2，不能保证A
如果想保证A，就会发生结果不一样，不能保证C

### BASE理论

基本可用：出现不可预知故障但是还能用，比正常系统可能延迟高，可能在流量高的时候用户会到降级页面
软状态：允许多个不同节点的数据存在数据延时
最终一致性：

### 分布式事务解决方案

比如下订单，要进行创建订单和减库存，应该是要么同时成功要么同时失败。而在分布式系统中，可能会出现只完成一个的情况，就要用到分布式事务

- **2PC两段提交**：一个事务协调者负责回滚，多个事务参与者

  第一阶段投票，协调者找参与者问提交事务还是取消，参与者告诉协调者
  第二阶段提交，协调者收到后告诉参与者结果

- **本地消息表**：创建订单时，将减库存消息加⼊在本地事务中，⼀起提交到数据库存⼊本地消息表， 然后调⽤库存系统，如果调⽤成功则修改本地消息状态为成功，如果调⽤库存系统失败，则由后台定时任务从本地消息表中取出未成功的消息，重试调⽤库存系统 

- **MQ**：异步，性能好

- **Seata**：阿⾥开源的分布式事务框架，⽀持AT、TCC等多种模式，底层都是基于两阶段提交理论来 实现

  - AT模式主要关注多 DB 访问的数据一致性，当然也包括多服务下的多 DB 数据访问一致性问题

    第一阶段RM工作，注册分支事务，记录undolog，执行业务sql并提交，报告事务状态

    第二阶段提交时RM的工作，删除undolog

    第二阶段回滚时RM的工作，根据undolog恢复数据更新前

    牺牲C一致性，保证A可用性，不过最终一致性

  - XA：等各个分支提交事务，强一致，性能差

  - TCC 模式主要关注业务拆分，在按照业务横向扩展资源时，解决微服务间调用的一致性问题

    - **Transaction Coordinator (TC)（事务协调器）**： 事务协调器，维护全局事务的运行状态，负责协调并驱动全局事务的提交或回滚。
    - **Transaction Manager（TM）**： 控制全局事务的边界，负责开启一个全局事务，并最终发起全局提交或全局回滚的决议。
    - **Resource Manager (RM)（事务参与者）**： 控制分支事务，负责分支注册、状态汇报，并接收事务协调器的指令，驱动分支（本地）事务的提交和回滚。

```
我们当时是xx项目，主要使用到的seata的at模式解决的分布式事务seata的AT模型分为两个阶段：
1、阶段一RM的工作：(1) 注册分支事务 (2) 记录undo-log（数据快照）(3)执行业务sql并提交 (4)报告事务状态
2、阶段二提交时RM的工作：删除undo-log即可
3、阶段二回滚时RM的工作：根据undo-log恢复数据到更新前
at模式牺牲了一致性，保证了可用性，不过，它保证的是最终一致性
```

### 分布式事务接口幂等性

幂等：多次调用方法或接口不会改变业务状态，可以保证重复调用和单词调用结果一致

①数据库的唯一索引

②分布式锁，性能低

③token+redis，性能好，第一次请求生成token存到redis返回给前端，第二次带token处理经过redis验证

```
下单操作，采用的token+redis实现的，流程是这样的
第一次请求，也就是用户打开了商品详情页面，我们会发起一个请求，在后台生成一个唯一token存入redis，key就是用户的id，value就是这个token，同时把这个token返回前端
第二次请求，当用户点击了下单操作会后，会携带之前的token，后台先到redis进行验证，如果存在token，可以执行业务，同时删除token；如果不存在，则直接返回，不处理业务，就保证了同一个token只处理一次业务，就保证了幂等性
```

### xxl-job路由策略有哪些

xxl-job提供了很多的路由策略，我们平时用的较多就是：轮询、故障转移、分片广播…

### xxl-job任务执行失败怎么解决

第一：路由策略选择故障转移，优先使用健康的实例来执行任务

第二，如果还有失败的，我们在创建任务时，可以设置重试次数

第三，如果还有失败的，就可以查看日志或者配置邮件告警来通知相关负责人解决

### 大数据量任务同时要执行，怎么解决

我们会让部署多个实例，共同去执行这些批量的任务，其中任务的路由策略是分片广播

在任务执行的代码中可以获取分片总数和当前分片，按照取模的方式分摊到各个实例执行就可以了

### gateway底层

### 涉及到多个数据库的操作为什么要用分布式事务

因为在分布式系统中，数据存储在不同的数据库实例中，每个数据库实例都有自己的事务管理机制。当一个事务涉及到多个数据库时，需要确保这些数据库操作的一致性，即要么全部操作成功，要么全部失败。保持数据一致，避免脏数据，提高可靠性

### 分布式事务具体怎么通过消息队列来实现不同节点之间的事务协调和数据交互



# 分布式

### CAP理论

C：一致性	A：可用性	P：分区容错性
不能同时保证CAP

P指的是两个分区之间可能无法通信，所以一定要保证P
C指的是假设写操作之后的读操作必须返回值。假如a给g1写操作10改成20，同时读g2，那么最后结果不一样
A指的是操作后立刻返回值。

那么如果想保证C，在操作g1时就要锁住g2，不能保证A
如果想保证A，就会发生结果不一样，不能保证C

### BASE理论

基本可用：出现不可预知故障但是还能用，比正常系统可能延迟高，可能在流量高的时候用户会到降级页面
软状态：允许多个不同节点的数据存在数据延时
最终一致性：

### 分布式事务解决方案

比如下订单，要进行创建订单和减库存，应该是要么同时成功要么同时失败。而在分布式系统中，可能会出现只完成一个的情况，就要用到分布式事务

- **2PC两段提交**：一个事务协调者负责回滚，多个事务参与者

  第一阶段投票，协调者找参与者问提交事务还是取消，参与者告诉协调者
  第二阶段提交，协调者收到后告诉参与者结果

- **本地消息表**：创建订单时，将减库存消息加⼊在本地事务中，⼀起提交到数据库存⼊本地消息表， 然后调⽤库存系统，如果调⽤成功则修改本地消息状态为成功，如果调⽤库存系统失败，则由后台定时任务从本地消息表中取出未成功的消息，重试调⽤库存系统 

- **MQ**：异步，性能好

- **Seata**：阿⾥开源的分布式事务框架，⽀持AT、TCC等多种模式，底层都是基于两阶段提交理论来 实现

  - AT模式主要关注多 DB 访问的数据一致性，当然也包括多服务下的多 DB 数据访问一致性问题

    第一阶段RM工作，注册分支事务，记录undolog，执行业务sql并提交，报告事务状态

    第二阶段提交时RM的工作，删除undolog

    第二阶段回滚时RM的工作，根据undolog恢复数据更新前

    牺牲C一致性，保证A可用性，不过最终一致性

  - XA：等各个分支提交事务，强一致，性能差

  - TCC 模式主要关注业务拆分，在按照业务横向扩展资源时，解决微服务间调用的一致性问题

    - **Transaction Coordinator (TC)（事务协调器）**： 事务协调器，维护全局事务的运行状态，负责协调并驱动全局事务的提交或回滚。

    - **Transaction Manager（TM）**： 控制全局事务的边界，负责开启一个全局事务，并最终发起全局提交或全局回滚的决议。

    - **Resource Manager (RM)（事务参与者）**： 控制分支事务，负责分支注册、状态汇报，并接收事务协调器的指令，驱动分支（本地）事务的提交和回滚。

### 接口幂等性设计

幂等：多次调用方法或接口不会改变业务状态，可以保证重复调用和单词调用结果一致

①数据库的唯一索引

②分布式锁，性能低

③token+redis，性能好，第一次请求生成token存到redis返回给前端，第二次带token处理经过redis验证

### 分布式任务调度

**xxl-job路由策略**：轮询，故障转移，分片广播。。。

**如果大数据量的任务同时需要执行怎么解决**：部署多个实例，共同执行批量任务，路由策略是分片广播

### 分布式id，解决方案

在开发中，我们通常会需要⼀个唯⼀ID来标识数据，如果是单体架构，我们可以通过数据库的主键，或 直接在内存中维护⼀个⾃增数字来作为ID都是可以的，但对于⼀个分布式系统，就会有可能会出现ID冲突，此时有以下解决⽅案： 

- **uuid**，这种⽅案复杂度最低，但是会影响存储空间和性能 

- **利⽤单机数据库的自增主键**，作为分布式ID的⽣成器，复杂度适中，ID⻓度较之uuid更短，但是受 到单机数据库性能的限制，并发量⼤的时候，此⽅案也不是最优⽅案 

- **利⽤redisr的特性来⽣成id**，⽐如redis的⾃增命令，这种方案和单机数据库(mysql)相⽐，性能有所提⾼，可以适当选⽤ 

- **雪花算法**，底层原理就是通过某台机器在某⼀毫秒内对某⼀个数字⾃增，这种⽅案也能保证分布式架构中 的系统id唯⼀，主要由以下三部分组成：

  1. **时间戳（41位）**：精确到毫秒级别的时间戳，可以支持该算法在未来几十年内不重复地生成ID。
  2. **机器ID（10位）**：5位数据中心ID和5位机器ID，支持1024个数据中心和每个数据中心内最多1024台机器。可以根据业务需求进行扩展。
  3. **序列号（12位）**：每毫秒内生成的ID序列号，支持同一节点同一毫秒内生成最多4096个ID。

  整个ID构成的格式如下：

  | 1位 | 41位时间戳 | 10位机器ID | 12位序列号 |

  其中，第1位是符号位，始终为0，不参与ID生成。对于Java语言，可以通过Snowflake算法实现一个线程安全、高性能的ID生成工具类。

# RabbitMQ

### RabbitMQ如何保证消息不丢失

我们要保证消息的不丢失。主要从三个层面考虑

第一个是开启生产者确认机制，确保生产者的消息能到达队列，如果报错可以先记录到日志中，再去修复数据

第二个是开启持久化功能，确保消息未消费前在队列中不会丢失，其中的交换机、队列、和消息都要做持久化

第三个是开启消费者确认机制，可以设置为auto，由spring确认消息处理成功后完成ack，当然也需要设置一定的重试次数，我们当时设置了3次，如果重试3次还没有收到消息，就将失败后的消息投递到异常交换机，交由人工处理

### RabbitMQ消息重复消费问题

消费者是设置了自动确认机制，当服务还没来得及给MQ确认的时候，服务宕机了，导致服务重启之后，又消费了一次消息。这样就重复消费了

处理订单，有一个业务的唯一标识，我们在处理消息时，先到数据库查询一下，这个数据是否存在，如果不存在，说明没有处理过，这个时候就可以正常处理这个消息了。如果已经存在这个数据了，就说明消息重复消费了，我们就不需要再消费了

分布式锁，数据库的锁

### 死信

消费失败；过期的消息；消息堆积满，最早的消息会变成死信

### rabbitmq怎么实现延迟队列

死信交换机+ttl消息存活时间。消息成为死信，队列绑定一个死信交换机，在死信交换机上绑定其他队列，发消息的时候可以按照需求指定TTL的时间，这样就实现了延迟队列的功能了。

### 如果有100万消息堆积在MQ , 如何解决

第一：提高消费者的消费能力 ,可以使用多线程消费任务

第二：增加更多消费者，提高消费速度。使用工作队列模式, 设置多个消费者消费消费同一个队列中的消息

第三：扩大队列容积，提高堆积上限可以使用RabbitMQ惰性队列，惰性队列的好处主要是

①接收到消息后直接存入磁盘而非内存

②消费者要消费消息时才会从磁盘中读取并加载到内存

③支持数百万条的消息存储

### RabbitMQ的高可用机制

镜像模式集群。

镜像队列结构是一主多从，所有操作都是主节点完成，然后同步给镜像节点，如果主节点宕机后，镜像节点会替代成新的主节点，不过在主从同步完成前，主节点就已经宕机，可能出现数据丢失

丢数据可以采用仲裁队列，与镜像队列一样，都是主从模式，支持主从数据同步，主从同步基于Raft协议，强一致。并且使用起来也非常简单，不需要额外的配置，在声明队列的时候只要指定这个是仲裁队列即可

### rabbitmq如何流量削峰

- 消息确认机制，可以确保消息在被消费者正确处理后才从队列中移除，避免消息在消费者端未处理完时被不断地推送
- 延迟队列，分散不同的时间

### rabbitmq实现分布式锁

- 可以设置一个独占队列，使得只有一个消费者可以连接该队列。可以视为一种锁的资源
- 生产者需要锁的时候，尝试向该队列发送一条消息，如果成功进入队列就是获取了锁
- 在另一个线程中，有一个消费者不断地监听这个队列，然后拿出来，表示锁被获取
- 当生产者完成任务后，可以选择删除队列或者发布一条特定消息来释放锁

# 网络

### OSI七层参考模型有哪些

物理层：管理计算机通信设备和网络媒体之间的互通，如线缆、集线器、网卡等。FTP、IMAP4、POP3、SSH、TELNET…

数据链路层：负责网络寻址、错误侦测和改错。Wi-Fi（IEEE 802.11）、ARP、WiMAX（IEEE 802.16）、PPP、PPPoE、L2TP…

网络层：决定数据的路径选择和转寄。IP（v4·v6）、ICMP（v6）、IGMP、Ipsec…

传输层：主要负责端到端的通信。TCP、UDP、PPTP、TLS/SSL…

会话层：负责在数据传输中设置和维护计算机网络中两台计算机之间的通信连接

表达层：把数据转换为能与接收者的系统格式兼容并适合传输的格式

应用层：提供为应用软件而设的接口，以设置与另一应用软件之间的通信DNS、HTTP

### TCP/IP四层模型

数据链路层；网络层；传输层；应用层

### 在浏览器中输入网址，点击访问会发生什么

1、**校验URL**
    浏览器会检测这个url是否正确存在，如果不合法，返回一个默认的页面。（比如，如果输入的不是合法的网址，浏览器将调用默认搜索引擎比如百度，对输入的内容进行搜索，返回搜索结果页）。
2、**DNS解析**
    浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址。解析优先级依次为：浏览器缓存 => 系统缓存 => 路由器缓存 => 本地域名服务器（LDNS） => 顶级域名服务器

3、**建立TCP连接（三次握手**）
    当解析得到目的地的IP地址之后，在进行http请求之前，需要先建立TCP连接。TCP建立连接的过程，即三次握手。

4、**发送HTTP请求**
    HTTP协议定义了几种请求方式，比如：GET/POST/PUT/DELETE等等，在浏览器输入URL进行请求，属于GET方法。
    一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成。
    请求头部的最后会有一个空行，表示请求头部结束，接下来为请求数据，这一行非常重要，必不可少。

```
请求行： 包括请求方式、请求地址、协议版本
请求头： 包括一系列 key:value格式的数据。比如目标服务器的主机名和端口号，请求体的长度，客户端可以接受的响应内容的语言。
请求数据：真正请求所需要的数据，比如登录时的账号密码。
```

5、**服务器处理请求并返回HTTP报文**
    请求到达服务器，服务器经过后端自定义的规则进行处理。比如经过Nginx进行路由，如果后端业务是由JAVA语言的SpringCloud实现,可能经过网关路由，鉴权，然后经过一系列的过滤器、拦截器，再到实际的业务代码。当执行完毕后，将执行结果组装成HTTP响应报文返回。

6**、浏览器解析渲染页面**
    浏览器对响应报文进行解析渲染，这个过程包括数据解析，资源加载（比如JS、CSS、图片）。

### DNS解析的过程

1. 本地 DNS 查询：如果该 URL 不在本地 DNS 缓存中，则向运营商的 DNS 发送查询请求。如果上层 DNS 服务器缓存了该记录，则会直接返回给本地 DNS；否则会依次向根域名服务器、顶级域名服务器、权限域名服务器查询，直至找到负责该域名的权威 DNS 服务器。
2. 权威 DNS 查询：当本地 DNS 找到负责这个域名的权威 DNS 后，会向权威 DNS 服务器发送一个查询请求，查询域名对应的 IP 地址等映射信息。
3. 权威 DNS 返回结果：权威 DNS 返回所查询的IP地址等映射信息（也有可能返回错误消息或者没有返回结果），同时本地 DNS 具有缓存功能，可以将获取到的域名信息保存在本地缓存中，以供后续使用。
4. HTTP 请求响应：客户端（如浏览器）收到 IP 地址后，便使用该地址向指定的服务器发起 HTTP 请求，并等待服务器返回请求结果，这样客户端才能在浏览器中看到对应的网页内容。

### Http和Https的区别

其实HTTPS就是从HTTP加上加密处理（一般是SSL安全通信线路）+认证+完整性保护

**区别**：
1、http需要拿到ca证书，需要钱
2、端口不一样，http是80，https443
3、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
4、http和https使用的是完全不同的连接方式（http的连接很简单，是无状态的；HTTPS 协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。）

### HTTP状态码

- 状态码200：状态码200表示服务器响应成功，也就是服务器找到了客户端请求的内容，并且将内容返回给客户端。

- 状态码302：状态码302代表临时跳转。例如：URL地址A可以向URL地址B上跳转，但这并不是永久性的，在经过一段时间后，URL地址A还可能向URL地址C上跳转。

- 状态码301 ：状态码301和状态码302相似，不同的是状态码301往往代表的是永久性的重定向，值得注意的是，这种重定向跳转，从严格意义来讲不是服务器跳转，而是客户端跳转的。这个“跳”的动作是服务器是通过回传状态码301来下达给客户端的，让客户端完成跳转。

- 状态码304：服务器通过返回状态码304可以告诉客户端请求资源成功，但是这个资源不是由服务器提供返回给客户端的，而是客户端本地浏览器缓存中就有的这个资源，因为可以从缓存中获取这个资源，从而节省传输的开销。

- 状态码403：状态码403代表请求的服务器资源权限不够，也就是说，没有权限去访问服务器的资源，或者请求的IP地址被封掉了。

- 状态码404：状态码404代表服务器上没有该资源，或者说服务器找不到客户端请求的资源，是最常见的请求错误码。
- 状态码500：状态码500代表程序错误，也就是说请求的网页程序本身报错了。在服务器端的网页程序出错。由于现在的浏览器都会对状态码500做一定的处理，所以在一般情况下会返回一个定制的错误页面。

### TCP三次握手

①客户向服务端发送SYN报文，表示客户请求建立连接

②服务器收到后如果同意链接就向客户端返回一个SYN-ACK报文

③客户端收到服务器的报文后，也会发送一个ACK报文作为响应，表示确认了服务器的报文

### 能否简化3次握手

不能，如果第2次握手时报文丢失，客户端收不到服务端的报文，客户端就不会向服务端发送数据，也会忽略服务端发来的数据

### 四次挥手

①客户端向服务端发出连接释放报文。释放连接报文包含FIN标志位(FIN=1)、序列号seq=1101(100+1+1000，其中的1是建立连接时占的一个序列号)

②服务端收到客户端发的FIN报文后给客户端回复确认报文，会通知相应的应用程序，客户端到服务端方向的连接已经释放

③服务端将最后数据(比如50个字节)发送完毕后就向客户端发出连接释放报文

④客户端收到服务端发的FIN报文后，向服务端发出确认报文

### 挥手为什么需要四次 

因为只有在客户端和服务端都没有数据要发送的时候才能断开TCP。而客户端发出FIN报文时只能保证客户端没有数据发了，服务端还有没有数据发客户端是不知道的。而服务端收到客户端的FIN报文后只能先 回复客户端一个确认报文来告诉客户端我服务端已经收到你的FIN报文了，但我服务端还有一些数据没发完，等这些数据发完了服务端才能给客户端发FIN报文

### 四次挥手中fin-wait，time-wait发生在第几次

fin-wait：12；time-wait：4

### TCP和UDP区别

- tcp面向连接传输，传输前要先建立连接；udp不需要连接，即刻传输数据
- tcp一对一服务；udp支持一对一、一对多、多对多
- tcp保证数据可靠性；udp不能保证
- tcp有拥塞控制和流量控制，保证传输安全性；udp没有，即使网络很慢也不会影响发送速率
- tcp首部开销较长，如果不用选项字段是20个字节；udp固定8个字节
- tcp流式传输没有边界，保证顺序和可靠；udp一个包一个包发送，有边界，可能丢包和乱序

### TCP和UDP的使用场景

- tcp面向连接能保证数据可交付，所以用于FTP文件传输，HTTP/HTTPS
- udp无连接随时发送简单高效，所以用于包总量较少的通信如DNS，视频音频，广播通信

### TCP协议如何保证可靠传输

1. **基于数据块传输** ：应用数据被分割成 TCP 认为最适合发送的数据块，再传输给网络层，数据块被称为报文段或段。
2. **对失序数据包重新排序以及去重**：TCP 为了保证不发生丢包，就给每个包一个序列号，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据就可以实现数据包去重。
3. **校验和** : TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。
4. **超时重传** : 当发送方发送数据之后，它启动一个定时器，等待目的端确认收到这个报文段。接收端实体对已成功收到的包发回一个相应的确认信息（ACK）。如果发送端实体在合理的往返时延（RTT）内未收到确认消息，那么对应的数据包就被假设为已丢失并进行重传。
5. **流量控制** : TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议（TCP 利用滑动窗口实现流量控制）。
6. **拥塞控制** : 当网络拥塞时，减少数据的发送。

### get和post区别

* get重点在从服务器上获取资源，post重点在向服务器发送数据；

* Get传输的数据量小，因为受URL长度限制，但效率较高； Post可以传输大量数据，所以上传文件时只能用Post方式；

* get是不安全的，因为get请求发送数据是在URL上，是可见的，可能会泄露私密信息，如密码等； post是放在请求头部的，是安全的

  

### 转发和重定向的区别

1.重定向访问服务器两次，转发只访问服务器一次。

2.转发页面的URL不会改变，而重定向地址会改变

3.转发只能转发到自己的web应用内，重定向可以重定义到任意资源路径。

4.转发是服务器行为；重定向是客户端行为。转发在服务器端完成的；重定向是在客户端完成的。

5.转发不会执行转发后的代码；重定向会执行重定向之后的代码。

### cookie和session的区别

- Cookie可以存储在浏览器或者本地，Session只能存在服务器

- session 能够存储任意的 java 对象，cookie 只能存储 String 类型的对象
- Session比Cookie更具有安全性（Cookie有安全隐患，通过拦截或本地文件找得到你的cookie后可以进行攻击）
- Session占用服务器性能，Session过多，增加服务器压力
- 单个Cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个Cookie，Session是没有大小限制和服务器的内存大小有关。

### 什么是对称加密与非对称加密 

- 对称密钥加密是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即 如何安全地将密钥发给对方； 
- 非对称加密是指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。 由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性；但是和对称加密比起来，非常的慢

### session与token区别 

- session机制存在服务器压力增大，CSRF跨站伪造请求攻击，扩展性不强等问题；
- session存储在服务器端，token存储在客户端
- token提供认证和授权功能，作为身份认证，token安全性比session好； 
- session这种会话存储方式方式只适用于客户端代码和服务端代码运行在同一台服务器上，token适 用于项目级的前后端分离（前后端代码运行在不同的服务器下）

# ElasticSearch

### es核心概念

- 索引：存储数据的位置，相当于数据库
- 映射：定义了每个字段的类型，字段所使用的分词器等，相当于表结构
- 文档：最小数据单元，json格式，相当于一行数据
- 类型：相当于一个表

### es原理

- 倒排索引：将文档中的每个词条和包含他的所有文档建立映射。这样搜索的时候只需要找索引中的词条，不用遍历所有文档
- 分布式架构：将数据分片存在不同的节点上，使得es能水平扩展，提高了容错性和处理能力。还支持副本，不同节点复制数据
- 文档存储：每个文档时json，包含多个字段，字段不同类型。文档的存储和检索是es的核心操作之一
- 分词器分析器：分词器将文本切分成一个个词条，分析器对词条进行处理
- 倒排索引的更新：es使用实时索引的机制，使得文档的索引过程几乎是即时的，从而保证了数据的实时性。

### 为什么用es

①数据库查询性能低，用模糊查询时左边有通配符不走索引查全表，效率低

②数据库功能弱

### es应用场景

海量数据的查询、日志数据的分析、实时数据的分析

假如一个分布式系统有 1000 台机器，系统出现故障时，我要看下日志，还得一台一台登录上去查看，是不是非常麻烦？日志接入ElasticSearch

在电商项目中，ElasticSearch用于存储状态为正在上架的商品

# 集合

### 常见的集合

- Collection：
  - List：ArrayLIst，LinkedLIst，Vector
  - Set：HashSet，LinkedHashSet，TreeSet

- Map：HashMap，LinkedHashMap，TreeMap，HashTable

### Set、List、Map区别

- List有索引，有序，可重复，可以为null
- Set无序，不可重复，只允许一个null
- Map键值对
- List底层数组和链表，Set、Map有红黑树和哈希存储
- Set基于Map实现

### ArrayList

底层：动态数组

扩容机制：new一个默认空的Object数组，第一次add初始容量10，扩容*1.5

### Vector

相对于ArrayList，remove和add等方法加synchronized锁，线程安全

扩容机制：初始10，扩容*2

### ArrayList和LinkedList区别

ArrayList：底层基于数组实现，查找快，增删慢

LinkedList：底层基于双向链表实现，查找慢，增删快，占空间大

### HashMap原理

JDK1.7：数组+链表 

JDK1.8：数组+链表/红黑树

初始16，到0.75就*2

当链表长度超过树化阈值 8 时，先尝试扩容来减少链表长度，如果数组容量已经 >=64，才会进行树化

### 哪些集合类是安全的

- Vector，比ArrayLIst多了个synchronized锁
- Collections.SynchronizedList(new ArrayLIst())
- 利用锁机制，在访问list之前获取锁，try里面访问list，finally里面释放锁
- hashTable：就比hashMap多了个synchronized (线程安全)，不建议使用。
- ConcurrentHashMap

### HashMap、HashTable和CurrentHashMap三者的区别

1. **线程安全性**：
   - `HashMap`：非线程安全。多个线程同时对 `HashMap` 进行修改可能导致不一致的结果。
   - `HashTable`：线程安全。所有的方法都是同步的，即使是只读方法也是如此。但这也带来了性能上的开销，因为在多线程环境下，同步操作可能导致性能下降。
   - `ConcurrentHashMap`：也是线程安全的，但与 `HashTable` 不同，`ConcurrentHashMap` 采用了更细粒度的锁机制(分段锁)，因此在多线程环境下，它的性能通常比 `HashTable` 更好。
2. **迭代器支持**：
   - `HashMap`：支持使用迭代器遍历，但不保证遍历顺序。
   - `HashTable`：同样支持使用迭代器遍历，但同样不保证遍历顺序。
   - `ConcurrentHashMap`：支持使用迭代器遍历，并且通常会返回一个弱一致性的遍历结果。弱一致性意味着在遍历期间可能会看到修改的结果，但不会抛出并发修改异常。
3. **Null 值和Null 键**：
   - `HashMap`：允许键和值为 `null`。
   - `HashTable`：不允许键或值为 `null`，否则会抛出 `NullPointerException`。
   - `ConcurrentHashMap`：与 `HashMap` 类似，允许键和值为 `null`。
4. **性能**：
   - 在单线程环境下，`HashMap` 的性能通常优于 `HashTable`，因为 `HashMap` 不需要进行额外的同步操作。
   - 在多线程环境下，`ConcurrentHashMap` 的性能通常优于 `HashTable`，因为它采用了更细粒度的锁机制，允许更高的并发性。

总的来说，如果在单线程环境下使用，`HashMap` 是一个更好的选择；如果在多线程环境下使用，`ConcurrentHashMap` 更适合。`HashTable` 虽然也是线程安全的，但由于性能相对较差，已经很少在新的代码中使用了。

### HashTable和CurrentHashMap在并发处理上的区别

- `HashTable`：由于只有一个全局锁，因此在高并发情况下，性能可能会受到影响，因为所有线程都需要竞争同一个锁。
- `ConcurrentHashMap`：通过分段锁，可以支持更高的并发度。即使多个线程同时操作不同的分段，它们也不会相互阻塞，因此在高并发情况下，性能通常比 `HashTable` 更好。

### ConcurrentHashMap原理

ConcurrentHashMap 是一种线程安全的高效Map集合，jdk1.7和1.8也做了很多调整。

JDK1.7的底层采用是分段的数组+链表 实现

JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。在jdk1.7中 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和HashMap类似，是一 种数组和链表结构，一个 Segment 包含一个HashEntry 数组，每个 HashEntry 是一个链表结构 的元素，每个 Segment 守护着一个HashEntry数组里的元素，当对 HashEntry 数组的数据进行修 改时，必须首先获得对应的 Segment的锁。

Segment 是一种可重入的锁 ReentrantLock，每个 Segment 守护一个HashEntry 数组里得元 素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 锁在jdk1.8中的ConcurrentHashMap 做了较大的优化，性能提升了不少。首先是它的数据结构与jdk1.8的hashMap数据结构完全一致。其次是放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现，synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲 突，就不会产生并发 , 效率得到提升

### 6.HashMap和HashTable区别

1. HashMap非线程安全；HashTable线程安全，所有的方法都是同步的
2. HashMap允许键和值为null；不允许键或值为null
3. 单线程环境下，HashMap性能好于HashTable，因为不需要额外的同步
4. HashMap支持使用迭代器遍历，但不保证遍历顺序；HashTable同样支持使用迭代器遍历，但同样不保证遍历顺序

# 多线程

### 进程，线程，协程

进程时操作系统分配资源的基本单位，线程是进程内部的执行单元，而协程是一种用户态的轻量级线程由程序员显示管理。

**区别**：

**根本区别：**进程是操作系统资源分配的基本单元，而线程是处理器任务调度的和执行的基本单位。

**资源开销：**每个进程都有自己独立的代码和空间(程序上下文)，程序之间的切换会有较大的开销；线程可以看作轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器(PC)，线程之间切换的开销小。

**包含关系：**如果一个进程内有多个线程，则执行的过程不是一条线的，而是多条线（多个线程），共同完成；线程是进程的一部分，可以把线程看作是轻量级的进程。

**内存分配：**同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的。

进程是正在运行程序的实例，进程中包含了线程，每个线程执行不同的任务

不同的进程使用不同的内存空间，在当前进程下的所有线程可以共享内存空间

线程更轻量，线程上下文切换成本一般上要比进程上下文切换低(上下文切换指的是从一个线程切换到另一个线程)
### 进程间通信方式
管道，消息队列，内存共享，信号量，Socket
### 并发，并行，串行

并发：多个任务在同一个CPU上，按照细分的时间片轮流交替进行

并行：单位时间内，多个处理器同时处理多个任务

串行：n个任务由一个处理器按顺序进行

### 创建线程的方式

①继承Thread类

②实现runnable接口

③实现callable接口

④线程池创建

### runnable和callable区别

- runnable的run方法没有返回值，callable有，用future调用
- callable支持返回执行结果
- callable的call方法能抛异常，runnable的run方法只能在内部消化

### run和start区别

start：用来启动线程，通过该线程调用run方法执行run方法中所定义的逻辑代码。start只能调用一次

run：封装了要被线程执行的代码，可以被调用多次

### 线程状态

新建、可运行、终结、阻塞、等待和有时限等待六种

关于线程的状态切换情况比较多。我分别介绍一下

当一个线程对象被创建，但还未调用 start 方法时处于新建状态，调用了start 方法，就会由新建进入可运行状态。如果线程内代码已经执行完毕，由可运行进入终结状态。当然这些是一个线程正常执行情况。

如果线程获取锁失败后，由可运行进入 Monitor 的阻塞队列阻塞，只有当持锁线程释放锁时，会按照一定规则唤醒阻塞队列中的阻塞线程，唤醒后的线程进入可运行状态

如果线程获取锁成功后，但由于条件不满足，调用了 wait() 方法，此时从可运行状态释放锁等待状态，当其它持锁线程调用 notify() 或 notifyAll() 方法，会恢复为可运行状态

还有一种情况是调用 sleep(long) 方法也会从可运行状态进入有时限等待状态，不需要主动唤醒，超时时间到自然恢复为可运行状态

![image-20240420172354049](C:\Users\camel\AppData\Roaming\Typora\typora-user-images\image-20240420172354049.png)

### sleep和wait区别

它们两个的相同点是都可以让当前线程暂时放弃 CPU 的使用权，进入阻塞状态。不同点主要有三个方面：

第一：方法归属不同

sleep(long) 是 Thread 的静态方法。而 wait()，是 Object 的成员方法，每个对象都有

第二：线程醒来时机不同

线程执行 sleep(long) 会在等待相应毫秒后醒来，而 wait() 需要被 notify 唤醒，wait() 如果不唤醒就一直等下去

第三：锁特性不同

wait 方法的调用必须先获取 wait 对象的锁，而 sleep 则无此限制

wait 方法执行后会释放对象锁，允许其它线程获得该对象锁（相当于我放弃cpu，但你们还可以用）

而 sleep 如果在 synchronized 代码块中执行，并不会释放对象锁（相当于我放弃 cpu，你们也用不了）

### 如何停止一个正在运行的线程

第一：可以使用退出标志，使线程正常退出，也就是当run方法完成后线程终止，一般我们加一个标记

第二：可以使用线程的stop方法强行终止，不过一般不推荐，这个方法已作废

第三：可以使用线程的interrupt方法中断线程，内部其实也是使用中断标志来中断线程

我们项目中使用的话，建议使用第一种或第三种方式中断线程

### 新建 T1、T2、T3 三个线程，如何保证它们按顺序执行

可以这么做，在多线程中有多种方法让线程按特定顺序执行，可以用线程类的**join**()方法在一个线程中启动另一个线程，另外一个线程完成该线程继续执行。

比如说：使用join方法，T3调用T2，T2调用T1，这样就能确保T1就会先完成而T3最后完成

### synchronized底层原理

synchronized 底层使用的JVM级别中的Monitor 来决定当前线程是否获得了锁，如果某一个线程获得了锁，在没有释放锁之前，其他线程是不能或得到锁的。synchronized 属于悲观锁。

synchronized 因为需要依赖于JVM级别的Monitor ，相对性能也比较低

### Monitor

monitor对象存在于每个Java对象的对象头中，synchronized 锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因monitor内部维护了三个变量

- WaitSet：保存处于Waiting状态的线程

- EntryList：保存处于Blocked状态的线程

- Owner：持有锁的线程

只有一个线程获取到的标志就是在monitor中设置成功了Owner，一个monitor中只能有一个Owner

在上锁的过程中，如果有其他线程也来抢锁，则进入EntryList 进行阻塞，当获得锁的线程执行完了，释放了锁，就会唤醒EntryList 中等待的线程竞争锁，竞争的时候是非公平的。

### synchronized锁升级

Java中的synchronized有偏向锁、轻量级锁、重量级锁三种形式，分别对应了锁只被一个线程持有、不同线程交替持有锁、多线程竞争锁三种情况。

重量级锁：底层使用的Monitor实现，里面涉及到了用户态和内核态的切换、进程的上下文切换，成本较高，性能比较低。

轻量级锁：线程加锁的时间是错开的（也就是没有竞争），可以使用轻量级锁来优化。轻量级修改了对象头的锁标志，相对重量级锁性能提升很多。每次修改都是CAS操作，保证原子性

偏向锁：一段很长的时间内都只被一个线程使用锁，可以使用了偏向锁，在第一次获得锁时，会有一个CAS操作，之后该线程再获取锁，只需要判断mark word中是否是自己的线程id即可，而不是开销相对较大的CAS命令一旦锁发生了竞争，都会升级为重量级锁

### ReentrantLock的使用方式和底层原理

ReentrantLock是一个可重入锁:，调用 lock 方法获取了锁之后，再次调用lock，是不会再阻塞，内部直接增加重入次数 就行了，标识这个线程已经重复获取一把锁而不需要等待锁的释放。

ReentrantLock是属于juc报下的类，属于api层面的锁，跟synchronized一样，都是悲观锁。通过lock()用来获取锁，unlock()释放锁。它的底层实现原理主要利用**CAS+AQS**队列来实现。它支持公平锁和非公平锁，两者的实现类似构造方法接受一个可选的公平参数（默认非公平锁），当设置为true时，表示公平锁，否则为非公平锁。公平锁的效率往往没有非公平锁的效率高

### CAS和AQS

**CAS**的全称是： Compare And Swap(比较再交换);它体现的一种乐观锁的思想，在无锁状态下保证线程操作数据的原子性。

- CAS使用到的地方很多：AQS框架、AtomicXXX类

- 在操作共享变量的时候使用的自旋锁，效率上更高一些

- CAS的底层是调用的Unsafe类中的方法，都是操作系统提供的，其他语言实现

**AQS**的话，其实就一个jdk提供的类AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架。

内部有一个属性 state 属性来表示资源的状态，默认state等于0，表示没有获取锁，state等于1的时候才标明获取到了锁。通过cas 机制设置 state 状态

在它的内部还提供了基于 FIFO 的等待队列，是一个双向列表，其中

- tail 指向队列最后一个元素

- head 指向队列中最久的一个元素

其中我们刚刚聊的ReentrantLock底层的实现就是一个AQS。

### synchronized和Lock区别 

1. 锁的获取方式：synchronized 是隐式获取锁的，即在进入 synchronized 代码块或方法时自动获取锁，退出时自动释放锁；而 Lock 需要程序显式地获取锁和释放锁，即需要调用 lock() 方法获取锁，调用 unlock() 方法释放锁。
2. 锁的性质：synchronized 是可重入的互斥锁，即同一个线程可以多次获得同一把锁，而且锁的释放也只能由获得锁的线程来释放；Lock 可以是可重入的互斥锁，也可以是非可重入的互斥锁，还可以是读写锁。
3. 锁的粒度：synchronized 是以代码块和方法为单位进行加锁和解锁，而 Lock 可以精确地控制锁的范围，可以支持多个条件变量。
4. 性能：在低并发的情况下，synchronized 的性能优于 Lock，因为 Lock 需要显式地获取和释放锁，而 synchronized 是在 JVM 层面实现的；在高并发的情况下，Lock 的性能可能优于 synchronized，因为 Lock 可以更好地支持高并发和读写分离的场景。

### 死锁

指两个或两个以上进程(线程)在执行过程中，由于竞争资源或由于彼此通信造成的一种堵塞的现象，若无外力的作用下，都将无法推进，此时的系统处于死锁状态

个线程需要同时获取多把锁，这时就容易发生死锁，举个例子来说：

t1 线程获得A对象锁，接下来想获取B对象的锁

t2 线程获得B对象锁，接下来想获取A对象的锁

这个时候t1线程和t2线程都在互相等待对方的锁，就产生了死锁

### 死锁产生的必要条件

1. **互斥条件（Mutual Exclusion）**：
   - 至少有一个资源必须是不能被共享的，即一次只能被一个进程或线程占用。当某个资源被一个进程占用时，其他进程必须等待释放。
2. **不可抢占条件（Hold and Wait）**：
   - 进程已经持有了至少一个资源，但又提出了新的资源请求，并且由于资源不能被抢占，所以进程必须等待其他进程释放它们所持有的资源。
3. **占有且等待条件（Hold and Wait）**：
   - 进程已经占有了至少一个资源，但又提出了新的资源请求，并且由于它还在等待其他资源，所以它不会释放已经占有的资源。
4. **循环等待条件（Circular Wait）**：
   - 存在一种循环等待的资源分配链，即进程集合中的每个进程都在等待下一个进程所持有的资源，形成了一个闭环。

### 如何避免死锁

一次申请所有资源

占有部分资源的线程尝试申请其它资源，如果申请不到，可以主动释放它占有的资源。

按序来申请资源

### volatile

volatile 是一个关键字，可以修饰类的成员变量、类的静态成员变量，主要有两个功能

第一：保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的,volatile关键字会强制将修改的值立即写入主存。

第二： 禁止进行指令重排序，可以保证代码执行有序性。底层实现原理是，添加了一个内存屏障，通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化

### 线程池的种类

1. 固定线程数的线程池，核心线程数和最大线程数一样，没有救急线程。适用于任务量已知，相对耗时的任务；
2. 单线程化的线程池，核心线程数和最大线程数都是1，所有队列FIFO执行。适用于按照顺序执行的任务；
3. 可缓存线程池，核心线程数0，阻塞队列不存储元素。适合任务数比较密集但是每个人物执行时间较短的任务；
4. 可以延迟执行的固定线程数的线程池，schedule(任务，n，秒)

### 线程池的核心参数

在线程池中一共有7个核心参数：

1. 核心线程数目

2. 最大线程数目 = 核心线程+救急线程的最大数目

3. 救急线程生存时间

4. 时间单位

5. 阻塞队列

6. 线程工厂 - 可以定制线程对象的创建，例如设置线程名字、是否是守护线程等

7. 拒绝策略 - 当所有线程都在繁忙，workQueue 也放满时，会触发拒绝策略 在拒绝策略中又有4中拒绝策略

 当线程数过多以后，第一种是抛异常、第二种是由调用者执行任务、第三是丢弃当前的任务，第四是丢弃最早排队任务。默认是直接抛异常。

### 线程池的执行原理

首先判断线程池里的核心线程是否都在执行任务，如果不是则创建一个新的工作线程来执行任务。如果核心线程都在执行任务，则线程池判断工作队列是否已满，如果工作队列没有满，则将新提交的任务存储在这个工作队 列里。如果工作队列满了，则判断线程池里的线程是否都处于工作状态，如果没有，则创建一个新的工作线程来执行任 务。如果已经满了，则交给拒绝策略来处理这个任务。

### 线程池的拒绝策略

1. 拒绝任务时，会直接抛异常RuntimeException
2. 当新任务被提交后直接被丢弃掉，也不会给你任何的通知，相对而言存在一定的风险，因为我们提交的时候根本不知道这个任务会被丢弃，可能造成数据丢失。
3. 会丢弃任务队列中的头结点，通常是存活时间最长的任务，同理它也存在一定的数据丢失风险。
4. 当有新任务提交后，则把这个任务交于提交任务的线程执行，也就是谁提交任务，谁就负责执行任务。这样做主要有两点好处。
   - 第一点新提交的任务不会被丢弃，这样也就不会造成业务损失。
   - 第二点好处是，由于谁提交任务谁就要负责执行任务，这样提交任务的线程就得负责执行任务，而执行任务又是比较耗时的，在这段期间，提交任务的线程被占用，也就不会再提交新的任务，减缓了任务提交的速度，相当于是一个负反馈。在此期间，线程池中的线程也可以充分利用这段时间来执行掉一部分任务，腾出一定的空间，相当于是给了线程池一定的缓冲期。

### 哪里用了多线程

es数据批量导入

在我们项目上线之前，我们需要把数据量的数据一次性的同步到es索引库中，但是当时的数据好像是1000万左右，一次性读取数据肯定不行（oom异常），如果分批执行的话，耗时也太久了。所以，当时我就想到可以使用线程池的方式导入，利用CountDownLatch+Future来控制，就能大大提升导入的时间。

在我做那个xx电商网站的时候，里面有一个数据汇总的功能，在用户下单之后需要查询订单信息，也需要获得订单中的商品详细信息（可能是多个），还需要查看物流发货信息。因为它们三个对应的分别三个微服务，如果一个一个的操作的话，互相等待的时间比较长。所以，我当时就想到可以使用线程池，让多个线程同时处理，最终再汇总结果就可以了，当然里面需要用到Future来获取每个线程执行之后的结果才行

rabbitMQ消息堆积，使用线程池，异步消费

### ThreadLocal的理解

是一个类，可以实现对线程里面资源对象的线程隔离，让每个线程各用各的资源对象，避免争用引发的线程安全问题

并且实现了线程内的资源共享

### ThreadLocal底层原理

在ThreadLocal内部维护了一个一个 ThreadLocalMap 类型的成员变量，用来存储资源对象

当我们调用 set 方法，就是以 ThreadLocal 自己作为 key，资源对象作为value，放入当前线程的 ThreadLocalMap 集合中

当调用 get 方法，就是以 ThreadLocal 自己作为 key，到当前线程中查找关联的资源值

当调用 remove 方法，就是以 ThreadLocal 自己作为 key，移除当前线程关联的资源值

### ThreadLocal使用场景

**典型场景1：** 每个线程需要一个独享的对象（通常是工具类，典型需要使用的类有SimpleDateFormat和Random）

**典型场景2：** 每个线程内需要保存全局变量（例如在拦截器中获取用户信息），可以让不同方法直接使用，避免参数传递的麻烦。

### 如何处理多线程环境下的资源共享，如何保证数据安全

- 使用synchronized，确保同一时间只能有一个线程可以访问资源
- 使用线程安全的集合类，如vector，concurrenthashmap，hashtable等
- 避免共享锁

### 乐观锁和悲观锁

**悲观锁**：假设数据在大多数情况下会发生冲突，因此在访问数据之前先获取锁，并且假定在数据被修改之前会发生冲突，例如通过 synchronized 关键字

**乐观锁**：乐观锁假设数据在大多数情况下不会发生冲突，因此在访问数据时不会立即加锁，而是直接访问数据，然后在更新数据时检查数据是否发生了变化。如果数据没有发生变化，则更新成功；如果数据发生了变化，则更新失败，需要进行重试或者放弃更新。

### volatile具有原子性吗

不能，计数器为例，number++被拆分成三个部分，主内存中拿到，加1操作，写回主内存中，当多个线程并发执行写回指令的时候，会出现写回主内存覆盖问题，所以不能保证原子性

### volatile和synchronized关键字有什么区别

volatile关键字是线程同步的轻量级实现，所以volatile性能肯定比synchronized关键字要好。但是volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代码块。synchronized关键字在JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，实际开发中使用 synchronized 关键字的场景还是更多一些。
多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞

volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证。
volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized关键字解决的是多个线程之间访问资源的同步性。

### 公平锁和非公平锁？效率？

公平锁执行流程获取锁时，先将线程自己添加到等待队列的队尾并休眠，当某线程用完锁之后，会去唤醒等待队列中队首的线程尝试去获取锁，锁的使用顺序也就是队列中的先后顺序，在整个过程中，线程会从运行状态切换到休眠状态，再从休眠状态恢复成运行状态，但线程每次休眠和恢复都需要从用户态转换成内核态，而这个状态的转换是比较慢的，所以公平锁的执行速度会比较慢。

非公平锁执行流程当线程获取锁时，会先通过 CAS 尝试获取锁，如果获取成功就直接拥有锁，如果获取锁失败才会进入等待队列，等待下次尝试获取锁。这样做的好处是，获取锁不用遵循先到先得的规则，从而避免了线程休眠和恢复的操作，这样就加速了程序的执行效率

# JVM

### JVM由那些部分组成，运行流程是什么

四大部分，类加载器、运行时数据区、执行引擎、本地库接口

它们的运行流程是：

- 第一，类加载器把Java代码转换为字节码

- 第二，运行时数据区把字节码加载到内存中，而字节码文件只是JVM的一套指令集规范，并不能直接交给底层系统去执行，而是有执行引擎运行

- 第三，执行引擎将字节码翻译为底层系统指令，再交由CPU执行去执行，此时需要调用其他语言的本地库接口来实现整个程序的功能。

### 运行时数据区（JVM内存结构）

线程共享：堆、方法区

线程私有：虚拟机栈、本地方法栈、程序计数器

- 堆解决的是对象实例存储的问题，垃圾回收器管理的主要区域。

- 方法区可以认为是堆的一部分，用于存储已被虚拟机加载的信息，常量、静态变量、即时编译器编译后的代码。

- 栈解决的是程序运行的问题，栈里面存的是栈帧，栈帧里面存的是局部变量表、操作数栈、动态链接、方法出口等信息。

- 本地方法栈与栈功能相同，本地方法栈执行的是本地方法，一个Java调用非Java代码的接口。

- 程序计数器（PC寄存器）程序计数器中存放的是当前线程所执行的字节码的行数。JVM工作时就是通过改变这个计数器的值来选取下一个需要执行的字节码指令。

### 程序计数器的作用

多线程会给每个任务分配时间片执行时间，一个处理器只会处理执行一个线程，如果当前线程的时间片用完了就会挂起，程序计数器会记录这次执行的行号，等到下一次执行时直接用

### Java堆

线程共享的区域。主要用来保存对象实例，数组等，当堆中没有内存空间可分配给实例，也无法再扩展时，则抛出OutOfMemoryError异常。

在JAVA8中堆内会存在年轻代、老年代

- Young区被划分为三部分，Eden区和两个大小严格相同的Survivor区，其中，Survivor区间中，某一时刻只有其中一个是被使用的，另外一个留做垃圾收集时复制对象用。在Eden区变满的时候， GC就会将存活的对象移到空闲的Survivor区间中，根据JVM的策略，在经过几次垃圾收集后，任然存活于Survivor的对象将被移动到Tenured区间。

- Tenured区主要保存生命周期长的对象，一般是一些老的对象，当一些对象在Young复制转移一定的次数以后，对象就会被转移到Tenured区。

### 方法区

与虚拟机栈类似。本地方法栈是为虚拟机执行本地方法时提供服务的。不需要进行GC。本地方法一般是由其他语言编写。

### 虚拟机栈

虚拟机栈是描述的是方法执行时的内存模型,是线程私有的，生命周期与线程相同,每个方法被执行的同时会创建栈桢。保存执行方法时的局部变量、动态连接信息、方法返回地址信息等等。方法开始执行的时候会进栈，方法执行完会出栈【相当于清空了数据】，所以这块区域不需要进行**GC**。

### 堆栈的区别

第一，栈内存一般会用来存储局部变量和方法调用，但堆内存是用来存储Java对象和数组的的。堆会GC垃圾回收，而栈不会。

第二、栈内存是线程私有的，而堆内存是线程共有的。

第三、两者异常错误不同，但如果栈内存或者堆内存不足都会抛出异常。

栈空间不足：java.lang.StackOverFlowError。堆空间不足：java.lang.OutOfMemoryError。

### 什么是类加载器，有哪些

JVM只会运行二进制文件，而类加载器的主要作用就是将字节码文件加载到**JVM**中，从而让Java程序能够启动起来。

常见的类加载器有4个

- 第一个是启动类加载器(BootStrap ClassLoader)：其是由C++编写实现。用于加载JAVA_HOME/jre/lib目录下的类库。

- 第二个是扩展类加载器(ExtClassLoader)：该类是ClassLoader的子类，主要加载JAVA_HOME/jre/lib/ext目录中的类库。

- 第三个是应用类加载器(AppClassLoader)：该类是ClassLoader的子类，主要用于加载classPath下的类，也就是加载开发者自己编写的Java类。

- 第四个是自定义类加载器：开发者自定义类继承ClassLoader，实现自定义类加载规则。

### 类装载的执行过程

类从加载到虚拟机中开始，直到卸载为止，它的整个生命周期包括了：

加载、验证、准备、解析、初始化、使用、卸载，7个阶段。其中，验证、准备和解析这三个部分统称为连接

1.加载：查找和导入class文件

2.验证：保证加载类的准确性

3.准备：为类变量分配内存并设置类变量初始值

4.解析：把类中的符号引用转换为直接引用

5.初始化：对类的静态变量，静态代码块执行初始化操作

6.使用：JVM 开始从入口方法开始执行用户的程序代码

7.卸载：当用户程序代码执行完毕后，JVM 便开始销毁创建的 Class 对象，最后负责运行的 JVM 也退出内存

### 双亲委派模型

如果一个类加载器收到了类加载的请求，它首先不会自己尝试加载这个类，而是把这请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传说到顶层的启动类加载器中，只有当父类加载器返回自己无法完成这个加载请求（它的搜索返回中没有找到所需的类）时，子类加载器才会尝试自己去加载

### 为什么采用双亲委派机制

第一、通过双亲委派机制可以避免某一个类被重复加载，当父类已经加载后则无需重复加载，保证唯一性。

第二、为了安全，保证类库API不会被修改

### Java垃圾回收机制

为了让程序员更专注于代码的实现，而不用过多的考虑内存释放的问题，所以，在Java语言中，有了自动的垃圾回收机制，也就是我们熟悉的GC(Garbage Collection)。

有了垃圾回收机制后，程序员只需要关心内存的申请即可，内存的释放由系统自动识别完成。

在进行垃圾回收时，不同的对象引用类型，GC会采用不同的回收时机

### 对象什么时候可以被垃圾器回收

如果一个或多个对象没有任何的引用指向它了，那么这个对象现在就是垃圾，如果定位了垃圾，则有可能会被垃圾回收器回收。

如果要定位什么是垃圾，有两种方式来确定，第一个是引用计数法，第二个是可达性分析算法通常都使用可达性分析算法来确定是不是垃圾

### 垃圾回收算法有哪些

标记清除算法、复制算法、标记整理算法、分代回收

### 分代回收

在java8时，堆被分为了两份：新生代和老年代，它们默认空间占用比例是1:2

对于新生代，内部又被分为了三个区域。Eden区，S0区，S1区默认空间占用比例是8:1:1

具体的工作机制是有些情况：

1）当创建一个对象的时候，那么这个对象会被分配在新生代的Eden区。当Eden区要满了时候，触发YoungGC。

2）当进行YoungGC后，此时在Eden区存活的对象被移动到S0区，并且当前对象的年龄会加**1**，清空Eden区。

3）当再一次触发YoungGC的时候，会把Eden区中存活下来的对象和S0中的对象，移动到S1区中，这些对象的年龄会加1，清空Eden区和S0区。

4）当再一次触发YoungGC的时候，会把Eden区中存活下来的对象和S1中的对象，移动到S0区中，这些对象的年龄会加1，清空Eden区和S1区。

5）对象的年龄达到了某一个限定的值（默认**15**岁 ），那么这个对象就会进入到老年代中。

当然也有特殊情况，如果进入Eden区的是一个大对象，在触发YoungGC的时候，会直接存放到老年代当老年代满了之后，触发**FullGC**。**FullGC**同时回收新生代和老年代，当前只会存在一个FullGC的线程进行执行，其他的线程全部会被挂起。 我们在程序中要尽量避免FullGC的出现。

### 新生代、老年代、永久代的区别

新生代主要用来存放新生的对象。

老年代主要存放应用中生命周期长的内存对象。

永久代指的是永久保存区域。主要存放Class和Meta（元数据）的信息。在Java8中，永久代已经被移除，取而代之的是一个称之为“元数据区”（元空间）的区域。元空间和永久代类似，不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存的限制。

### 垃圾回收器

- 串行垃圾收集器：新生代用复制算法，老年代用标记整理算法，垃圾回收的时候只能有垃圾回收的线程在工作，其他线程阻塞；

- 并行垃圾收集器：新生代用复制算法，老年代用标记整理算法，垃圾回收的时候多个线程进行回收工作，但是其他依然暂停；

- CMS（并发）垃圾收集器：标记清除算法，主要用于老年代，初始标记要清理的，时间很短，然后并发标记时其他线程可运行，然后重新标记预防发生变化，并发清理，其他线程可运行；

- G1垃圾收集器：新生代和老年代，复制算法，每个区没有比例，多一个大对象区。新生代标记->并发标记->混合收集

### Minor GC、Major GC、Full GC是什么

其实它们指的是不同代之间的垃圾回收

Minor GC 发生在新生代的垃圾回收，暂停时间短

Major GC 老年代区域的垃圾回收，老年代空间不足时，会先尝试触发MinorGC。Minor GC之后空间还不足，则会触发Major GC，Major GC速度比较慢，暂停时间长

Full GC 新生代 + 老年代完整垃圾回收，暂停时间长，应尽力避免

# 设计模式

### 代理模式

分为两个

目标对象：原对象，我们需要通过代理对象控制它的访问，扩展其功能。
代理对象：代理模式产生的对象，是原对象的替身，在原有基础上进行修改。
在不改变原对象代码的基础上对原对象的功能进行扩展

降低系统耦合度，扩展性好，保护目标对象

1.静态代理

- 接口方式实现，目标对象和代理对象都实现同一个接口，有公共方法，可以在代理对象中实现对目标对象功能的拓展
- 继承方式，代理对象继承目标对象

2.动态代理

- 基于jdk：实际上就是在内存中生产一个对象，该对象实现了指定的目标对象的所有接口，代理对象和目标对象是兄弟关系。
- cglib：基于父类的动态代理是在内存中生成一个对象，该对象继承了原对象，所以代理对象实际上就是原对象的子类。

### 单例模式

单例对象的类只能允许一个实例存在。在程序中多次使用同一个对象且作用相同的时候，为了防止频繁的创建对象，单例模式可以让程序在内存中创建一个对象，让所有的调用者都共享这一单例对象

- 饿汉式：在类加载的时候已经创建好该单例对象，类装载时完成实例化避免线程同步问题，线程安全，但如果没用就会造成内存浪费
- 懒汉式：在需要使用对象的时候才会去创建对象，每次访问加锁效率低，在多线程环境下需要考虑线程安全问题，可能会出现多线程竞争创建对象的情况

### 单例双重验证

第一次校验是否为null:

主要是为了实现返回单例，避免多余的加锁操作，以及锁的等待和竞争，如果条件不成立就说明已经生成实例，直接返回即可，提高程序执行的效率。

第二次校验是否为null:

第二次校验是关键，这里防止了多线程创建多个实例（一般为两个），这里的特殊情况是这样的：在未创建实例的情况下，A线程和B线程都通过了第一次校验（`singletonDoubleCheck`为空）,这时如果通过竞争B线程拿到了锁就会执行一次`new`操作，生成一个实例，然后B执行完了A就会拿到资源的锁，如果没有第二次判断的话，这时A线程也会执行一次`new`操作，这里就出现了第二个类实例，违背了单例原则。

```
// 第一次校验是否为null
        if (singletonDoubleCheck == null) {
            // 不为空则加锁
            synchronized (SingletonDoubleCheck.class) {
                // 第二次校验是否为null
                if (singletonDoubleCheck == null) {
                    singletonDoubleCheck = new SingletonDoubleCheck();
                }
            }
        }
```



### 工厂模式

将对象的实例化全部交给工厂去做，你只需要告诉工厂需要什么对象，然后工厂造出来就行

- 简单工厂：创建实例的方法通常为静态方法

  **简单工厂**（SimpleFactory）：是简单工厂模式的核心，负责实现创建所有实例的内部逻辑。工厂类的创建产品类的方法可以被外界直接调用，创建所需的产品对象。
  **抽象产品**（Product）：是简单工厂创建的所有对象的父类，负责描述所有实例共有的公共接口。
  **具体产品**（ConcreteProduct）：是简单工厂模式的创建目标。

- 工厂方法：可以使系统在不修改原来代码的情况下引进新的产品

  **抽象工厂**（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法 newProduct() 来创建产品。
  **具体工厂**（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。
  **抽象产品**（Product）：定义了产品的规范，描述了产品的主要特性和功能。
  **具体产品**（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。

- 抽象工厂：是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构，可生产多个等级的产品

  **抽象工厂**（Abstract Factory）：提供了创建产品的接口，它包含**多个**创建产品的方法 newProduct()，可以创建**多个**不同等级的产品。
  **具体工厂**（Concrete Factory）：主要是实现抽象工厂中的**多个**抽象方法，完成具体产品的创建。
  **抽象产品**（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有**多个**抽象产品。
  **具体产品**（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间是**多对一**的关系。

### 观察者模式

观察者模式通常由两个对象组成：观察者和被观察者。当被观察者状态发生改变时，它会通知所有的观察者对象，使他们能够及时做出响应

**优点：**

1. 被观察者和观察者对象之间不需要知道对方的具体实现，只需要知道对方的接口，**避免了紧耦合的关系**。
2. 由于被观察者对象并不关心具体的观察者是谁，所以在程序运行的过程中，可以动态地增加或者删除观察者对象，**增加了灵活性**。
3. **符合开闭原则**，当需要添加新的观察者时，只需要添加一个实现观察者接口的类，而不需要修改被观察者对象的代码。

**缺点：**

1. 当观察者没有被正确移除时，可能会导致**内存泄漏**的问题。
2. 实现观察者模式，需要定义多个接口和类，增加了**程序的复杂度**。
3. 在某些情况下，被观察者和观察者对象之间可能出现**循环依赖**的问题。

- 抽象被观察者（Subject）：定义了一个接口，包含了注册观察者、删除观察者、通知观察者等方法。
- 具体被观察者（ConcreteSubject）：实现了抽象被观察者接口，维护了一个观察者列表，并在状态发生改变时通知所有注册的观察者。
- 抽象观察者（Observer）：定义了一个接口，包含了更新状态的方法。
- 具体观察者（ConcreteObserver）：实现了抽象观察者接口，存储了需要观察的被观察者对象，并在被观察者状态发生改变时进行相应的处理。

1. 当一个对象的状态发生改变时，需要通知多个对象做出相应的响应。**例如，王者荣耀更新前，会通知所有用户要更新的时间。**
2. 当很多对象同时对某一个主题感兴趣时，可以采用观察者模式实现发布-订阅模式。**例如，生产者发送消息到消息队列中，并通知所有订阅此队列的消费者进行消费。**
3. 数据库开发中，当数据库表中的数据发生变化时，需要通知相关的模块进行更新或其他操作。**例如，当用户更新了数据库中的某个记录时，就可以通过观察者模式通知所有注册的监听器进行响应。**

### JavaIO 流中使用了哪些设计模式？

装饰模式，适配器模，工厂模式，NIO 中的文件目录监听服务使用到了观察者模式。

装饰者模式:就是在给一个已经存在的对象添加新的功能时，不需要改变现有的数据结构，也即不会出现类的数量爆炸的情况

适配器模式:为了解决两个不兼容接口或者是输出目标对象不兼容的兼容性问题。

工厂模式:用于创建对象，NIO 中大量用到了工厂模式

### Java 中 3 种常见 IO 模型

**BIO**：同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间

同步非阻塞 IO 模型中，应用程序会一直发起 read 调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间

**AIO**：异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作

**NIO** 可以看作是 I/O 多路复用模型

# 算法

### 排序

- **冒泡排序**：通过比较相邻元素的大小，依次将较大（或较小）的元素交换到数组的末尾（或开头），直到整个数组有序为止	
- **选择排序**：每次从未排序的部分选取最小（或最大）的元素，与未排序部分的第一个元素交换位置，直到整个数组有序
- **插入排序**：从第二个元素开始，依次将每个元素插入到已排序部分的适当位置，直到整个数组有序
- **快速排序**：通过选择一个基准元素，将数组分为两个子数组，小于基准元素的放在左边，大于基准元素的放在右边，然后递归地对子数组进行排序，
- **归并排序**：将数组分成两个子数组，分别对子数组进行排序，然后将排好序的子数组合并成一个有序数组，直到整个数组有序
- **堆排序**：构建一个最大（或最小）堆，然后将堆顶元素与堆的最后一个元素交换位置并移除，然后重新调整堆，直到整个数组有序重点

### 链表

由一系列节点组成，每个节点包含一个数据元素和一个指向下一个节点的引用（或指针）。链表的特点是每个节点都不是连续存储的，而是通过指针相互连接起来，形成一条链式结构。

- 单向链表：只能从头节点开始顺序访问，无法直接访问中间或末尾节点。
- 双向链表：还包含一个指向前一个节点，可以从头节点或尾节点开始访问，可以直接访问任意节点，查找元素时可以从头或尾节点开始搜索
- 循环链表：最后一个节点的指针指向头节点，形成一个环形结构，任意节点开始访问，遍历完整个链表后可以回到起始节点

### 二叉树

- 二叉搜索树：每个节点的左子树中的所有节点都小于该节点的值，而右子树中的所有节点都大于该节点的值， O(log n)
- 平衡二叉树：同上，然后保持了左右子树的高度差不超过1的性质，从而避免了二叉搜索树退化为链表的情况
  - 红黑树：自平衡的二叉搜索树，它在插入和删除节点时通过颜色标记和旋转操作来保持树的平衡
    - 节点颜色：根节点黑色，叶子节点黑色
    - 从根节点到每个叶子节点的路径上，黑色节点的数量相同；沿着任何路径，不能有连续的红色节点
- 完全二叉树：除了最后一层外，其他层的节点都被填满，并且最后一层的节点都尽量靠左排列

**前序遍历**：先访问根节点，然后按照左子树、右子树的顺序递归遍历左右子树

**中序遍历**：先按照左子树、根节点、右子树的顺序递归遍历左右子树，直到所有节点都被访问

**后序遍历**：先按照左子树、右子树、根节点的顺序递归遍历左右子树，直到所有节点都被访问

### 优先搜索

1. **深度优先搜索（DFS）**：
   - 深度优先搜索从起始节点开始，沿着一条路径尽可能深地搜索，直到到达末端节点或无法继续搜索为止，然后回溯到上一个节点，继续搜索其他路径。
   - 在实现中，通常使用递归或栈的方式来实现深度优先搜索。
   - DFS 可以用于解决回溯问题、寻找路径问题、拓扑排序等问题。
   - 优点是实现简单，空间复杂度较低，但可能会陷入局部最优解。
2. **广度优先搜索（BFS）**：
   - 广度优先搜索从起始节点开始，先访问起始节点的所有邻居节点，然后逐层地访问每个邻居节点的邻居节点，直到搜索到目标节点或搜索完整个图。
   - 在实现中，通常使用队列来存储待访问的节点，并逐层遍历。
   - BFS 可以用于解决最短路径问题、查找图中的连通分量、计算图的直径等问题。
   - 优点是能够找到最短路径，且不会陷入局部最优解，但需要额外的空间存储队列。

### 动态规划

将原问题分解为若干个子问题，并通过递推关系来求解这些子问题的解，然后将子问题的解组合起来得到原问题的解

1. **定义状态**：将原问题划分为若干个子问题，并定义状态表示问题的解。状态可以是一个或多个变量的组合，用来描述问题的特征。
2. **找到状态转移方程**：根据子问题之间的关系，找到状态之间的转移方程，即如何通过已知的状态计算出新的状态。这个过程通常通过递推关系来完成。
3. **初始化状态**：确定初始状态的值，即基本情况下子问题的解。
4. **计算状态**：根据状态转移方程，逐步计算出所有可能的状态的值，直到得到原问题的解。
5. **解决问题**：根据计算出的状态值，得到原问题的解

### 贪心算法

每一步都选择当前状态下的最优解，而不考虑之后的选择，即局部最优解能够导致全局最优解

1. 确定问题的贪心策略，即如何在当前状态下做出最优选择。

2. 利用贪心策略，逐步构造问题的解。

3. 验证所得解是否满足问题的要求，如果满足则算法结束，否则返回步骤1继续选择。

### 磁盘进程调度的算法

先来先服务；

最短寻道时间优先：优先处理的磁道是与当前磁头最近的磁道

电梯算法：磁头在磁道上按照一个方向移动，直到遇到最近的未完成的请求，然后改变方向继续移动

C-SCAN：类似于电梯算法，但在到达磁道的最后时不会改变方向，而是直接回到磁道的起始位置

### 哈夫曼树

树中距离根节点较近的叶子节点所代表的字符具有较短的编码，而距离根节点较远的叶子节点所代表的字符具有较长的编码

哈夫曼树的构建过程是通过贪心算法实现的。其基本思想是，首先根据字符出现的频率构建一个包含所有字符的最小堆（最小优先队列），然后反复从堆中选取两个频率最小的节点（字符）进行合并，构建出一个新的父节点，直到堆中只剩下一个节点为止，这个节点即为哈夫曼树的根节点

### 红黑树是怎么调整平衡的

通过旋转和颜色变换来实现的，调整的目的是使得树保持红黑树的五个性质：根节点为黑色、所有叶子节点为黑色、相邻节点不能都为红色、每个节点到其所有后代叶子节点的简单路径上包含相同数目的黑色节点、新插入的节点为红色

# 其他

### SPI机制，项目哪里用了

它是JDK内置的一种动态扩展点的实现。简单来说，就是我们可以定义一个标准的接口，然后第三方的库里面可以实现这个接口。

程序在运行的时候，会根据配置信息动态加载第三方实现的类，从而完成功能的动态扩展机制。

数据库驱动java.jdbc.Driver。JDK里面定义了数据库驱动类Driver，它是一个接口，JDK并没有提供实现。具体的实现是由第三方数据库厂商来完成的。在程序运行的时候，会根据我们声明的驱动类型，来动态加载对应的扩展实现，从而完成数据库的连接。

### 面向对象的特性

封装：是指将某事物的属性和行为包装到对象中，对外只开放一个可以访问它的接口
继承：子对象可以继承父对象的属性和行为
多态：指父对象中的同一个行为能在其多个子对象中有不同的表现

### 基本数据类型

8种
①整数类型：long、int、short、byte
②浮点类型：float、double
③字符类型：char
④布尔类型：boolean

### Java8新特性

**Lambda表达式**：允许在方法内部直接定义匿名函数，从而使得代码更加简洁和易读

```
(方法参数列表) -> {
	方法体
};
```

**stream流**：可以通过类似于SQL查询的方式对集合进行操作。它可以以函数式的方式进行过滤、映射、排序等操作，使得集合处理更加简洁高效

**元空间**：元空间是使用本地内存（Native Memory）来存储类的元数据，而不是使用JVM的堆内存。它的大小可以根据需要进行动态调整，并且在达到最大限制时可以自动进行扩展。这使得Java应用程序不再受到永久代大小的限制，并且更加稳定和可靠。

### NIO、BIO、AIO

**BIO(同步阻塞)**
服务端需要对客户端的每个请求处理完成后 才会继续接受客户端的请求
客户端也会等待服务端处理完请求后才会发送请求
通常会使用多线程去处理 因为BIO每个连接一个单独的线程

**NIO(同步非阻塞)**
NIO使用单线程或者只使用少量的多线程，一个请求一个线程，多个连接共用一个线程。
(即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。)
(可以使用资源池或者队列等手段实现异步的处理)

**AIO(异步非阻塞)**
AIO的读写方法都是异步的 完成后会主动调用回调函数

### 静态方法、实例方法

1. 在外部调用静态方法的时候，可以用类名.方法名进行调用，不必新创建一个对象；而实例方法则必须创建一个对象，通过该对象进行调用
2. 静态方法在访问本类成员时，只允许访问静态成员（静态成员变量和静态方法）；而实例方法没有限制。
3. 静态方法在类加载时就会被分配内存，无需创建对象实例；实例方法需要在创建对象实例后才会被分配内存。

### ==和equals()

== 是 Java 程序语言定义的一个**运算符**，用于比较两者是否相等，返回一个布尔类型值（true 或 false）。如果 == 两边比较的是基本数据类型的话，则比较变量的值，两者相等返回 true 反之返回 false；如果两边比较的引用类型，则比较的是引用变量所指的是否是同一个内存地址，是则返回 true 反之 false。

equals 是 Object 超类的一个方法，其功能是比较两个对象内存地址是否相等。Java中包装类型都重写了 equals 方法，将其实现成值比较，而不是地址比较，因为对于包装类型我们对值的比较实用性大于对地址的比较。

最后在说一下两者最大的一个区别可以说是一个为运算符，一个为方法，并且 == 既可以比较引用类型对象也可以比较基本类型，而 equals 只能比较引用类型对象。

### 二进制源码补码反码

1. **原码**：二进制数的最高位表示符号位，0表示正数，1表示负数，其余位表示数值的绝对值。
2. **反码**：正数的反码与原码相同，负数的反码是对应正数的各位取反（0变1，1变0）得到的。
3. **补码**：正数的补码与原码相同，负数的补码是对应正数的反码加1得到的。

### 异常处理机制、分类

- 编译时异常：这些异常通常是程序员可以预料到的、可以通过程序代码进行处理的异常，例如如 IOException、SQLException 等。
- 运行时异常：编译时不会检查的异常，通常是由程序的逻辑错误或者运行时环境导致的异常，例如数组下标越界、空指针异常等。

处理机制：抛异常；try-catch捕获异常

### 接口与抽象类区别

接口是抽象方法的集合，声明了一系列的方法操作，自身并不能做任何事情。如果一个类实现了某个接口，那么它必须实现这个接口的所有抽象方法。
抽象类是一个不能被实例化的类，它只能作为其他类的父类来使用。抽象类可以包含抽象方法和非抽象方法，其中抽象方法没有具体的实现，而非抽象方法有具体的实现代码。

- **实现方式的区别**：一个类可以实现多个接口，但只能继承一个抽象类。
- **成员变量的区别**：接口中只能定义常量（即静态 final 字段），而抽象类可以定义普通成员变量。
- **构造函数的区别**：接口没有构造函数，而抽象类可以有构造函数。
- **方法实现的区别**：接口中的方法默认都是公共的抽象方法，不包含具体的实现代码；而抽象类可以包含抽象方法和非抽象方法，其中抽象方法没有具体的实现，而非抽象方法有具体的实现代码。

### 过滤器和拦截器有什么区别

- 过滤器来自于 Servlet，而拦截器来自于 Spring 框架
- 请求的执行顺序是：请求进入容器 > 进入过滤器 > 进入 Servlet > 进入拦截器 > 执行控制器（Controller）。过滤器会先执行，然后才会执行拦截器，最后才会进入真正的要调用的方法。
- 过滤器的实现是基于方法回调的。 而拦截器是基于动态代理（底层是反射）实现的
- 拦截器主要用来实现项目中的业务判断的，比如：登录判断、权限判断、日志记录等业务。 而过滤器通常是用来实现通用功能过滤的，比如：敏感词过滤、字符集编码设置、响应数据压缩等功能

### 拦截器主要作用

主要用来实现项目中的业务判断的，比如：登录判断、权限判断、日志记录等业务

### 过滤器和拦截器哪个范围更大

拦截器的范围更广，可以用于更多种类的应用和场景，而过滤器主要用于 Web 应用中的请求处理。

### 过滤器是如何实现的

@WebFilter 注解，配置过滤的 URL 规则，然后再实现 Filter 接口，重写接口中的 doFilter 方法

- void init：容器启动（初始化 Filter）时会被调用，整个程序运行期只会被调用一次。用于实现 Filter 对象的初始化。
- void doFilter：具体的过滤功能实现代码，通过此方法对请求进行过滤处理，其中 FilterChain 参数是用来调用下一个过滤器或执行下一个流程。
- void destroy：用于 Filter 销毁前完成相关资源的回收工作。

### 拦截器如何实现

第一步，创建一个普通的拦截器，实现 HandlerInterceptor 接口，并重写接口中的相关方法；

第二步，将上一步创建的拦截器加入到 Spring Boot 的配置文件中。

### 方法重载和重写的区别

- 重载：是指在同一个类中，可以定义多个方法名相同但参数列表不同的方法。这些方法根据参数的类型、顺序或数量的不同来区分。String的valueOf
- 重写：是指子类重新实现了父类中已有的方法。子类通过继承父类的方法，并对其进行修改或补充。

### 重载的返回值有没有变化

不能，因为它不是方法签名的组成部分，方法签名是由：方法名称 + 参数类型 + 参数个数组成的一个唯一值，如果变了jvm不知道调用哪个方法

### 深拷贝浅拷贝

- 浅拷贝只会复制对象的第一层内容，而不会递归复制对象的所有引用类型成员
- 深拷贝会递归地复制对象及其所有引用类型成员，直到所有层级的对象都被复制

### 包装类的缓存机制

在某个固定范围内，这些包装类型的对象会被预先创建并缓存起来，以便重复使用。当创建新的包装类型对象时，会先检查缓存池中是否已经存在相同值的对象，如果存在，则直接返回缓存中的对象，而不是创建新的对象

### 包装原理

**自动装箱**：自动装箱是指将基本数据类型自动转换为对应的包装类对象，编译器会自动进行装箱操作，valueOf

**拆箱**：拆箱是指将包装类对象转换为对应的基本数据类型，编译器会自动进行拆箱操作，xxxValue()

### String为什么不可变

（1）类内部所有的字段都是final修饰的。

（2）类内部所有的字段都是私有的，也就是被private修饰。

（3）类不能够被集成和拓展。

（4）类不能够对外提供哪些能够修改内部状态的方法，setter方法也不行。

在Java程序中String类型是使用最多的，这就牵扯到大量的增删改查，每次增删改差之前其实jvm需要检查一下这个String对象的安全性，就是通过hashcode，当设计成不可变对象时候，就保证了每次增删改查的hashcode的唯一性

### 为什么要同时重写equals 和 hashcode方法

`equals`方法用于判断两个对象是否相等。默认情况下，`equals` 方法比较的是对象的引用，即是否指向同一块内存。但在很多情况下，我们更关心对象的内容是否相等。

通过重写 `equals` 方法，可以根据对象的业务逻辑来定义相等性判断，比如比较对象的属性值。

`hashCode` 方法返回对象的哈希码，用于在哈希表等数据结构中进行快速查找。如果两个对象被 `equals` 判定为相等，它们的哈希码应该相等。因此，为了保持一致性，需要同时重写 `hashCode` 方法。

### io流

字节流、字符流；输入流、输出流

### jdk1.8，接口是否可以实现default的方法

可以，默认实现的方法

### error、exception区别

它们都是Throwable类的子类

Exception代表了在程序执行过程中可能出现的异常情况，通常是由程序错误或者外部条件导致的

Error通常表示严重的问题，它通常是由于系统错误或者资源耗尽等无法处理的情况导致的

### 怎么自定义异常

自定义检查异常需要继承Exception

自定义运行时异常需要继承RuntimeException

### try-catch-finally，如果在catch块中return了，finally块中的代码还会执行吗

能

### 线程池异步提交，服务在提交过程中被杀死了，怎么办

如果线程池异步提交任务后服务被杀死，可以通过设置任务的超时时间或者在任务执行前检查服务状态来处理。另外，可以使用带超时参数的submit方法，并在超时后取消任务执行。

### Synchronized底层实现，与ReentrantLock区别。这里答得不是很好。

Synchronized底层实现主要是通过对象头中的锁标记位来实现对象的加锁和解锁。与ReentrantLock相比，Synchronized是Java语言级别的关键字，在语法上更加简洁，而ReentrantLock是Java中的一个类，提供了更灵活的锁机制，例如可重入性、可中断性等，并且提供了公平性和非公平性锁两种实现。

### 多线程中的锁是怎么用的？

多线程中的锁主要通过synchronized关键字或者Lock接口的实现类（如ReentrantLock）来使用。在需要保护临界区的代码块前加上synchronized关键字或者Lock的lock方法来获取锁，在临界区代码执行完毕后再释放锁。

### 说说如何使用Synchronized锁？有哪几种用法？

使用Synchronized锁的几种方式包括：

- 对象锁：使用synchronized关键字修饰普通方法或代码块，锁住对象实例。
- 类锁：使用synchronized关键字修饰静态方法或代码块，锁住类的Class对象。
- 锁定对象：通过synchronized关键字锁定指定的对象。
- 重入锁：在同一个线程中可以重复获取已经持有的锁。

### 实际场景中如何进行加锁来实现平衡性能问题？

在实际场景中，为了实现平衡性能问题，可以根据具体情况选择合适的锁粒度，避免过大的锁粒度导致的性能瓶颈，同时又要避免过小的锁粒度导致的锁竞争问题。另外，可以使用读写锁来实现对共享资源的读写分离，提高并发性能。

### 项目难点

**查询商品详情**

将商品的各种信息（基本信息、分类信息、规格信息、价格、图片、详细描述等）封装成一个Map对象，并返回给调用者。其中涉及到了多次数据库查询以及多表关联、数据转换和数据组装的过程。

**入口大流量限制**

例如有10W用户来抢购10件商品，我们只放100个用户进来。

采取发放令牌机制（控制流量），根据商品id和一串`uuid`产生一个令牌存入`redis`中同时引入了秒杀大闸，目的是流量控制，比如当前活动商品只有100件，我们就发放500个令牌，秒杀前会先发放令牌，令牌发放完则把后来的用户挡在这一层之外，控制了流量。获取令牌后会对比`redis`中用户产生的令牌，对比成功才可以购买商品

### 秒杀中如何处理超卖问题？



直接由数据库操作库存的sql语句如下所示。依靠MySQL中的排他锁实现

```sql
 update table_prmo set num = num - 1 WHERE id = 1001 and num > 0
```

**利用`redis`的单线程特性预减库存处理秒杀超卖问题！！！**

1. 在系统初始化时，将商品以及对应的库存数量预先加载到`Redis`缓存中；（缓存预热）

2. 接收到秒杀请求时，在`Redis`中进行预减库存（decrement），当`Redis`中的库存不足时，直接返回秒杀失败，否则继续进行第3步；

3. 将请求放入**异步队列**中，返回正在排队中；

4. 服务端异步队列（MQ）将请求出队，出队成功的请求可以生成秒杀订单，减少数据库库存，返回秒杀订单详情。

   

### RabbitMQ分布式事务

为了确保数据一定成功发送到MQ。 在同一事务中，增加一个记录表的操作, 记录`每一条发往MQ的数据以及它的发送状态` 于是我们在订单系统中增加一个本地信息表，生成订单时,也保存本地信息表。利用RabbitMQ事务发布确认机制(confirm) 开启后，MQ准确受理消息会返回回执，然后就能知道如何更新本地信息表了。如果出现回执没收到、消息状态修改失败等特殊情况 `兜底方案:定时检查消息表，超时没发送成功，再次重发`，运单系统收到消息数据后,突然宕机,或者访问运单DB时,DB突然宕机,消息数据不就丢了吗!!!于是需要以下特性:

➢ 幂等性 防止重复消息数据的处理，一次用户操作，只对应一次数据处理

➢ 开启`手动ACK模式` 由消费者控制消息的重发/清除/丢弃

消费者处理失败，需要MQ再次重发给消费者。 出现异常一般会重试几次，由消费者自身记录重试次数，并进行次数控制，消费者处理失败，直接丢弃或者转移到死信队列(DLQ)

### 查询商品详情

1. 首先，更新商品详情的最后更新时间为当前时间。
2. 然后，根据传入的商品详情对象（`productDetails`）中的商品ID查询出对应的商品信息（`product1`）。
3. 接着，获取旧的商品详情对象（`old`），用于比较旧价格和新价格。
4. 如果旧价格与商品表中的价格相等，说明旧数据是最小价格，需要进行比较和更新操作：
   - 如果旧价格小于新价格，说明新价格成为了最小价格，需要更新关联商品的价格，并将商品表中的价格更新为最小价格。
   - 如果旧价格大于新价格，说明新价格仍然是最小价格，只需更新商品表中的价格为新价格。
5. 如果旧价格与商品表中的价格不相等，说明新价格比商品表中的价格小，直接将商品表中的价格更新为新价格。
6. 最后，更新商品详情表中的数据，并返回更新的结果。

### 如何解决MySQL数据库和ES数据不一致问题？（美团）（字节）



1. **双写模式：**  我们采取MySQL作为主要的数据存储，利用MySQL的事务特性维护数据一致性，使用ElasticSearch进行数据汇集和查询，此时es与数据库的同步方案就尤为重要。

   **保证es与数据库的同步方案：**

   1、首先添加商品入数据库，添加商品成功后，商品入ES，若入ES失败，将失败的商品ID放入redis的缓存队列（或MQ），且失败的商品ID入log文件（若出现redis挂掉，可从日志中取异常商品ID然后再入ES），
   task任务每秒刷新一下redis缓存队列，若是从缓存队列中取到商品ID，则根据商品ID从数据库中获取商品数据然后入ES。  

2. **canal组件控制一致性**

### 如果数据库写失败了怎么办？ES写失败了怎么办？



若入ES失败，将失败的商品ID放入redis的缓存队列（或MQ），且失败的商品ID入log文件（若出现redis挂掉，可从日志中取异常商品ID然后再入ES），
task任务每秒刷新一下redis缓存队列，若是从缓存队列中取到商品ID，则根据商品ID从数据库中获取商品数据然后入ES。  

### 分布式会话问题

`token+redis`解决**分布式会话**问题。

Token是服务端生成的一串字符串，作为客户端进行请求的一个令牌，当第一次登录后，服务器生成一个`userToken`便将此Token返回给客户端，存入cookie中保存，以后客户端只需带上这个`userToken`前来请求数据即可，无需再次带上用户名和密码。二次登录时，只需要去`redis`中获取对应token的value，验证用户信息即可。

~~~java
// 用户第一次登录时，经过相关信息的验证后将对应的登录信息以及凭证（token）存入reids中
String uuid = UUID.rondom().toString();
redisTemplate.opsForValue().set(uuid, userModel);
// token下发到客户端存入cookie中进行保存

// 再次登录时cookie携带着token到redis中找到对应的value不为空，表示该用户已经登陆过了，如果查询结果为空，则让该用户重新登陆，然后将用户信息保存到redis中。
// 一般设置一个过期时间，表示的就是多久后用户的登录态就失效了。
~~~

